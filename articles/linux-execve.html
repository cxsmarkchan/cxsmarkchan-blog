<!DOCTYPE HTML>
<html>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="baidu-site-verification" content="iZA6IpYgQU" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    

    <title>linux源码分析：execve加载可执行文件 | cxsmarkchan的博客</title>
    <meta name="author" content="cxsmarkchan">
    
    <meta name="description" content="Ph.D. Electrical Engineering">
    
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta property="og:title" content="linux源码分析：execve加载可执行文件"/>
    <meta property="og:site_name" content="cxsmarkchan的博客"/>

    
    <meta property="og:image" content="undefined"/>
    

    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="alternate" href="/atom.xml" title="cxsmarkchan的博客" type="application/atom+xml">
    <link rel="stylesheet" href="/css/lib/materialize.min.css">
    <link rel="stylesheet" href="/css/lib/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

    
        <link rel="stylesheet" href="/css/lib/prettify-tomorrow-night-eighties.css" type="text/css">
    
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><img src="/weixin_favicon.png" style="position: absolute; left: -9999px; opacity: 0; filter: alpha(opacity=0);">

    <nav class="indigo">
    <div class="nav-wrapper">
        <a href="#" data-activates="main-menu" class="button-collapse">
            <i class="fa fa-navicon"></i>
        </a>
        <div class="">
            <a href="/" class="brand-logo hide-on-med-and-down">cxsmarkchan的博客</a>
            <ul class="right hide-on-med-and-down">
                
                    <li>
                        <a class="menu-home " href="/" >
                            <i class="fa fa-home "></i>
                            
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-archive " href="/archives" >
                            <i class="fa fa-archive "></i>
                            
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                            <i class="fa fa-bookmark "></i>
                            
                            分类
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-search modal-trigger " href="#search" >
                            <i class="fa fa-search "></i>
                            
                            搜索
                        </a>
                    </li>
                
            </ul>
            <div>
    <ul class="side-nav indigo darken-1" id="main-menu">
        
        <li class="side-user">
            <div class="row">
                <div class="col s4 no-padding">
                    <img class="avatar-image circle responsive-img" src="/about/cxs.jpg" alt="User Avatar">
                </div>
                <div class="info col s8 valign-wrapper no-padding">
                    <div class="valign">
                        <p class="name">cxsmarkchan</p>
                        <p class="desc">电力系统/优化/随机</p>
                    </div>
                </div>
            </div>
        </li>
        

        
            <li class="no-padding">
                <a class="waves-effect menu-home " href="/" >
                    <i class="fa fa-home "></i>
                    
                    首页
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-archive " href="/archives" >
                    <i class="fa fa-archive "></i>
                    
                    归档
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                    <i class="fa fa-bookmark "></i>
                    
                    分类
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-search modal-trigger " href="#search" >
                    <i class="fa fa-search "></i>
                    
                    搜索
                </a>
            </li>
        
    </ul>

    <ul class="side-nav indigo darken-1" id="category-menu">
    

            

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/生活/">
                    生活 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/linux/">
                    linux <span class="right">5 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/linux/源码/">
                    源码 <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/linux/内核/">
                    内核 <span class="right">2 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/优化/">
                    优化 <span class="right">8 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/优化/模型/">
                    模型 <span class="right">2 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/优化/理论/">
                    理论 <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/优化/算法/">
                    算法 <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/机器学习/">
                    机器学习 <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-1" collapse-level="1">
                <a class="no-padding" href="/categories/机器学习/模型/">
                    模型 <span class="right">3 篇</span></a>
                </a>
            </li>

        

    </ul>
</div>

        </div>
    </div>
</nav>

<div id="search" class="modal search-modal">
    <div class="row">
        <div class="input-field col s12">
              <input id="search-input" type="text">
              <label for="search-input">搜索</label>
        </div>

    </div>
    <div id="search-result" class="search-result col s12">

    </div>
</div>


    <main>
        <div class="container main-container">
    <nav class="page-nav hide-on-small-only">
    <div class="nav-wrapper indigo">
        <span class="breadcrumb">当前位置（分类目录）</span>
        
            
    
    
    <a class="breadcrumb" href="/categories/linux/">linux</a><a class="breadcrumb" href="/categories/linux/源码/">源码</a>


        

        
    </div>
</nav>

<article>
    <div class="card">
        <div class="card-content">
            

            <div class="article-title">
                
    
        <h1>linux源码分析：execve加载可执行文件</h1>
    


            </div>
            <time class="pink-link-context" datetime="2016-04-10T06:29:42.000Z"><a href="/articles/linux-execve.html">2016-04-10</a></time>

            <span id="busuanzi_container_page_pv" class="read-times-container">
    <i class="fa fa-eye"></i>
    <span id="busuanzi_value_page_pv"></span>
</span>

            
    <div class="tags-row">
        
            <a href="/tags/linux/" class="chip pink lighten-1">linux</a>
        
            <a href="/tags/源码/" class="chip pink lighten-1">源码</a>
        
            <a href="/tags/execve/" class="chip pink lighten-1">execve</a>
        
            <a href="/tags/进程/" class="chip pink lighten-1">进程</a>
        
    </div>


            <div class="toc pink-link-context hide-on-med-and-down">
    <ol class="section table-of-contents"><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#1-execve的使用方法"><span class="section table-of-contents-text">1 execve的使用方法</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#2-execve源码分析"><span class="section table-of-contents-text">2 execve源码分析</span></a><ol class="section table-of-contents-child"><li class="section table-of-contents-item section table-of-contents-level-2"><a class="section table-of-contents-link" href="#2-1-从execve到exec-binprm"><span class="section table-of-contents-text">2.1 从execve到exec_binprm</span></a></li><li class="section table-of-contents-item section table-of-contents-level-2"><a class="section table-of-contents-link" href="#2-2-load-elf-binary"><span class="section table-of-contents-text">2.2 load_elf_binary</span></a></li><li class="section table-of-contents-item section table-of-contents-level-2"><a class="section table-of-contents-link" href="#2-3-start-thread"><span class="section table-of-contents-text">2.3 start_thread</span></a></li></ol></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#3-小结"><span class="section table-of-contents-text">3 小结</span></a></li></ol>
</div>


            <div class="entry pink-link-context">
                <p>execve是linux中一个重要的系统调用，它用于将一个可执行文件加载如内存中并执行。在执行shell命令时，就会调用execve函数。有意思的是，execve并未创建新的进程，而是会把当前进程覆盖。本文分析execve的实现过程，以加深对linux可执行文件加载过程的理解。本文分析的源码来自<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6" target="_blank" rel="external">这里</a><br><a id="more"></a></p>
<p>原创内容： cxsmarkchan 陈晓爽<br>转载请注明出处<br><a href="http://www.xuetangx.com/courses/course-v1:ustcX+USTC001+_/about" target="_blank" rel="external">Linux内核分析</a>学习笔记</p>
<h1 id="1-execve的使用方法"><a href="#1-execve的使用方法" class="headerlink" title="1 execve的使用方法"></a>1 execve的使用方法</h1><p>execve的调用格式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,<span class="keyword">char</span> * <span class="keyword">const</span> argv[ ],<span class="keyword">char</span> * <span class="keyword">const</span> envp[ ])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>按照linux一切皆文件的思想，加载可执行程序，实际上是把一个二进制文件加载入内存。其中，<code>filename</code>为可执行文件名，<code>argv</code>为输入的参数，<code>envp</code>为环境参数。在执行shell命令时，我们只需输入filename和argv，而envp则由系统自动赋值。<br>为了演示execve的使用，首先看下面一段C代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str[] = &#123;<span class="string">"ls"</span>&#125;;</span><br><span class="line">    execve(<span class="string">"/bin/ls"</span>, str, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ls done!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码中用execve调用了linux的ls进程，用于显示当前目录下的文件。假设当前目录下有<code>test.cpp</code>和<code>a.out</code>两个文件，猜一下这段程序的运行结果是什么呢？从直觉上看，似乎应该是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.cpp a.out</span><br><span class="line">ls done!</span><br></pre></td></tr></table></figure></p>
<p>但实际上，运行结果是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.cpp a.out</span><br></pre></td></tr></table></figure></p>
<p>执行完execve后，那句printf语句为什么没有被执行呢？这正是execve的神奇之处：它没有创建新进程，而是用新加载的可执行文件把当前进程覆盖了！因此，执行完execve后，printf语句早已不存在。<br>因此，调用execve的时候，我们通常用如下程序，先fork一个子进程，并在子进程中加载可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char* str[] = &#123;&quot;ls&quot;&#125;;</span><br><span class="line">    int pid = fork();</span><br><span class="line">    if(pid == 0) &#123;</span><br><span class="line">        execve(&quot;/bin/ls&quot;, str, NULL);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        wait(NULL); // 等待子进程返回</span><br><span class="line">        printf(&quot;ls done!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序就可以得到预期的输出结果，即先输出ls的结果，再输出<code>ls done!</code>。</p>
<h1 id="2-execve源码分析"><a href="#2-execve源码分析" class="headerlink" title="2 execve源码分析"></a>2 execve源码分析</h1><h2 id="2-1-从execve到exec-binprm"><a href="#2-1-从execve到exec-binprm" class="headerlink" title="2.1 从execve到exec_binprm"></a>2.1 从execve到exec_binprm</h2><p>execve位于内核源码的<code>fs/exec.c</code>，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(execve,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> __user *, filename,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, argv,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, envp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_execve(getname(filename), argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">struct</span> filename *filename,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *__argv,</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *__envp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> user_arg_ptr argv = &#123; .ptr.native = __argv &#125;;</span><br><span class="line">	<span class="keyword">struct</span> user_arg_ptr envp = &#123; .ptr.native = __envp &#125;;</span><br><span class="line">	<span class="keyword">return</span> do_execve_common(filename, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见sys_execve函数调用了do_execve函数，而后者又调用了do_execve_common函数。do_execve_common函数中同样定义于<code>fs/exec.c</code>中，它包含了execve的主体部分，代码较长，我们只分析其中的主干部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_execve_common</span><span class="params">(<span class="keyword">struct</span> filename *filename,</span><br><span class="line">				<span class="keyword">struct</span> user_arg_ptr argv,</span><br><span class="line">				<span class="keyword">struct</span> user_arg_ptr envp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> linux_binprm *bprm; <span class="comment">//bprm用于维护程序执行的相关参数</span></span><br><span class="line">	<span class="keyword">struct</span> file *file;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	bprm = kzalloc(<span class="keyword">sizeof</span>(*bprm), GFP_KERNEL);</span><br><span class="line">	retval = prepare_bprm_creds(bprm); <span class="comment">//分配creds结构体，处理锁信息</span></span><br><span class="line"></span><br><span class="line">	check_unsafe_exec(bprm);</span><br><span class="line">    current-&gt;in_execve = <span class="number">1</span>; <span class="comment">//表明当前进程正在执行新程序，这个在进程调度中有意义</span></span><br><span class="line"></span><br><span class="line">	file = do_open_exec(filename); <span class="comment">//打开文件</span></span><br><span class="line"></span><br><span class="line">	sched_exec(); <span class="comment">//进程调度</span></span><br><span class="line"></span><br><span class="line">	bprm-&gt;file = file;</span><br><span class="line">	bprm-&gt;filename = bprm-&gt;interp = filename-&gt;name;</span><br><span class="line"></span><br><span class="line">	retval = bprm_mm_init(bprm); <span class="comment">//初始化内存映射</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下内容为填充bprm，录入输入参数、环境参数等信息</span></span><br><span class="line">	bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class="line">	bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class="line">	retval = prepare_binprm(bprm);</span><br><span class="line">	retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class="line">	bprm-&gt;exec = bprm-&gt;p;</span><br><span class="line">	retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">	retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装载程序</span></span><br><span class="line">    retval = exec_binprm(bprm);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//还原信息和释放内存等</span></span><br><span class="line">    current-&gt;in_execve = <span class="number">0</span>;</span><br><span class="line">    free_bprm(bprm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在do_execve_common中，最重要的工作是构建bprm结构体</strong>。bprm结构体中包含了装载应用程序需要的所有信息，这些信息正是在do_execve_common中录入。这里应该重点关注bprm-&gt;p，它代表了应用程序堆栈的当前位置。我们知道，在调用一个应用程序时，相关参数实际上是main函数的参数，而参数的传入方式是通过堆栈传递。因此，在初始化应用程序的时候，必须首先把参数压栈。这个操作是在copy_strings_kernel和copy_strings函数中完成的(这些函数中会修改bprm-&gt;p)。当这些操作完成后，bprm-&gt;p已经指向了当前的堆栈顶端，因此装载可执行程序时，只需要把堆栈指向bprm-&gt;p，即可顺利执行。</p>
<p>构建完bprm后，do_execve_common调用了exec_binprm函数，装载应用程序。该函数定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// exec_binprm</span><br><span class="line">// position: fs/exec.c</span><br><span class="line">static int exec_binprm(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t old_pid, old_vpid;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	/* Need to fetch pid before load_binary changes it */</span><br><span class="line">	old_pid = current-&gt;pid;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	old_vpid = task_pid_nr_ns(current, task_active_pid_ns(current-&gt;parent));</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	ret = search_binary_handler(bprm);</span><br><span class="line">	if (ret &gt;= 0) &#123;</span><br><span class="line">		audit_bprm(bprm);</span><br><span class="line">		trace_sched_process_exec(current, old_pid, bprm);</span><br><span class="line">		ptrace_event(PTRACE_EVENT_EXEC, old_vpid);</span><br><span class="line">		proc_exec_connector(current);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>其中最关键的语句是search_binary_handler，其功能是根据可执行文件的格式，查找相应的处理程序。</strong>其定义如下(只列举了重要语句)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_binary_handler</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> linux_binfmt *fmt;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = security_bprm_check(bprm);</span><br><span class="line">    </span><br><span class="line">	read_lock(&amp;binfmt_lock);</span><br><span class="line">    <span class="comment">// 查找合适的处理程序</span></span><br><span class="line">	list_for_each_entry(fmt, &amp;formats, lh) &#123; <span class="comment">//遍历formats列表</span></span><br><span class="line">		<span class="keyword">if</span> (!try_module_get(fmt-&gt;module)) <span class="comment">//判断文件格式是否匹配</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		read_unlock(&amp;binfmt_lock);</span><br><span class="line">		bprm-&gt;recursion_depth++;</span><br><span class="line">		retval = fmt-&gt;load_binary(bprm); <span class="comment">//处理程序</span></span><br><span class="line">		put_binfmt(fmt);</span><br><span class="line">		bprm-&gt;recursion_depth--;</span><br><span class="line">	&#125;</span><br><span class="line">	read_unlock(&amp;binfmt_lock);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数中用到了list_for_each_entry宏，这里不分析该宏的具体实现，只需知道它用于遍历formats中所有的列表项。formats列表中的每一项都是一个linux_binfmt结构体，代表了一种文件格式。每个变量中有一个名为load_binary的函数指针，指向相应的加载函数。例如，linux中最常用的ELF格式文件，其对应的加载函数即为load_elf_binary。这种实现方式类似于C++中的多态，也比较灵活，但内核实现需要借助很多宏，理解起来不如C++方便。<br><strong>在search_binary_handler中，formats被遍历，当找到匹配的文件格式时，load_binary函数即被调用。</strong>接下来，我们只分析load_elf_binary的源码。</p>
<h2 id="2-2-load-elf-binary"><a href="#2-2-load-elf-binary" class="headerlink" title="2.2 load_elf_binary"></a>2.2 load_elf_binary</h2><p>load_elf_binary位于<code>fs/binfmt_elf.c</code>，其代码很长，因为它需要对ELF格式的二进制文件进行解析。我们同样只看其中最主干的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//大量变量定义，此处未完全列举</span></span><br><span class="line">	<span class="keyword">char</span> * elf_interpreter = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> elf_entry; <span class="comment">//进程入口</span></span><br><span class="line">	<span class="keyword">struct</span> pt_regs *regs = current_pt_regs(); <span class="comment">//当前的进程信息</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> elfhdr elf_ex;</span><br><span class="line">		<span class="keyword">struct</span> elfhdr interp_elf_ex;</span><br><span class="line">	&#125; *loc; <span class="comment">//进程执行信息，包括进程入口等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//文件解析工作，此处省略</span></span><br><span class="line">    <span class="comment">////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (elf_interpreter) &#123; <span class="comment">// 动态链接</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> interp_map_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,</span><br><span class="line">					    interpreter,</span><br><span class="line">					    &amp;interp_map_addr,</span><br><span class="line">					    load_bias);</span><br><span class="line">                        </span><br><span class="line">		reloc_func_desc = interp_load_addr;</span><br><span class="line"></span><br><span class="line">		allow_write_access(interpreter);</span><br><span class="line">		fput(interpreter);</span><br><span class="line">		kfree(elf_interpreter);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 静态链接</span></span><br><span class="line">		elf_entry = loc-&gt;elf_ex.e_entry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(elf_phdata);</span><br><span class="line"></span><br><span class="line">	set_binfmt(&amp;elf_format);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//此处省略了设置内存映射的相关内容</span></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">	start_thread(regs, elf_entry, bprm-&gt;p); <span class="comment">//启动进程</span></span><br><span class="line">    </span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>该函数主要做了3部分工作：</strong></p>
<ol>
<li><strong>把可执行文件读入内存</strong></li>
<li><strong>根据读入的elf文件信息，设置可执行文件的入口</strong></li>
<li><strong>启动线程</strong></li>
</ol>
<p>从上述代码可见，在设置可执行文件入口的时候，需要根据程序是否有动态链接行为，决定进程的入口位置，此处不再展开说明。</p>
<h2 id="2-3-start-thread"><a href="#2-3-start-thread" class="headerlink" title="2.3 start_thread"></a>2.3 start_thread</h2><p>经过一番曲折，终于到了execve程序的末尾。上一节中load_elf_binary最后有这么一句话：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_thread(regs, elf_entry, bprm-&gt;p);</span><br></pre></td></tr></table></figure></p>
<p>这个语句即为启动新加载的程序了。在x86 32位系统中，start_thread定义在<code>arch/x86/kernel/process_32.c</code>中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_thread</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> new_ip, <span class="keyword">unsigned</span> <span class="keyword">long</span> new_sp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	set_user_gs(regs, <span class="number">0</span>);</span><br><span class="line">	regs-&gt;fs		= <span class="number">0</span>;</span><br><span class="line">	regs-&gt;ds		= __USER_DS;</span><br><span class="line">	regs-&gt;es		= __USER_DS;</span><br><span class="line">	regs-&gt;ss		= __USER_DS;</span><br><span class="line">	regs-&gt;cs		= __USER_CS;</span><br><span class="line">	regs-&gt;ip		= new_ip;</span><br><span class="line">	regs-&gt;sp		= new_sp;</span><br><span class="line">	regs-&gt;flags		= X86_EFLAGS_IF;</span><br><span class="line">    </span><br><span class="line">	set_thread_flag(TIF_NOTIFY_RESUME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们传入的3个参数，第1个参数regs即为当前进程的注册信息，在load_elf_binary中定义。第2个参数new_ip是入口指令位置，在load_elf_binary中，由elf_entry指定。第3个参数new_sp是堆栈位置，传入参数为bprm-&gt;p，这个信息很早的时候，在do_execve_common函数中即设置完毕。有了这3个参数，start_thread可以顺利执行，可执行程序也就加载完毕。</p>
<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>linux在装载和启动一个可执行程序的时候，主要做了如下工作：</p>
<ol>
<li>构建linux_binprm结构体，装载文件名、参数等信息，并完成堆栈信息的记录。</li>
<li>根据可执行文件的格式信息，查找相应的解析和加载程序。对于ELF程序，即为调用load_elf_binary函数。</li>
<li>在load_binary函数中，设置可执行程序的入口指令位置，并调用start_kernel，装入新的ip和sp，完成可执行程序的启动。</li>
</ol>
<p>值得注意的是，execve是在当前进程（调用execve函数的进程）上加载可执行文件，加载完毕后，原进程即被覆盖。如果不希望被覆盖，应该用fork创建新进程，再调用execve函数。</p>

                
<p class="pink-link-context">
    <a href="/articles/linux-schedule.html" rel="next" title="linux源码分析：schedule进程调度">
    上一篇：linux源码分析：schedule进程调度
  </a>
</p>



<p class="pink-link-context">
    <a href="/articles/linux-fork.html" rel="next" title="linux源码分析：fork复制进程">
    下一篇：linux源码分析：fork复制进程
  </a>
</p>


            </div>
			
        </div>
    </div>
</article>




    <section id="comment">
        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function() {
                this.page.url = 'http://cxsmarkchan.com/articles/linux-execve.html';
                this.page.identifier = 'articles/linux-execve.html';
            };
            (function() {
                var d = document,
                    s = d.createElement('script');
                s.src = '//cxsmarkchan-github-io.disqus.com/embed.js';
                s.setAttribute('data-timestamp', + new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the
            <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
        </noscript>
    </section>



</div>

        <div class="fixed-action-btn float-sitemap">
    <a class="btn-floating btn-large pink">
      <i class="fa fa-caret-square-o-up"></i>
    </a>
    <ul>
      <li><a class="btn-return-top btn-floating waves-effect green" title="回到顶部"><i class="fa fa-arrow-circle-o-up"></i></a></li>
      <li><a class="btn-floating waves-effect button-collapse yellow darken-1"  data-activates="main-menu" title="菜单"><i class="fa fa-navicon"></i></a></li>
    </ul>
  </div>

    </main>
    <footer class="page-footer indigo darken-1">
    
    <div class="footer-container container">
        <div class="row">
            
            <div class="social-group col m4 s12">
                <h5 class="white-text">社交</h5>
                
                    <a class="social-link" href="https://github.com/cxsmarkchan" target="_blank">
                        <i class="fa fa-2x fa-github"></i>
                    </a>
                
                    <a class="social-link" href="/atom.xml" target="_blank">
                        <i class="fa fa-2x fa-rss"></i>
                    </a>
                
                
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <div class="site-visitors-container white-text">
        <span>
            <i class="fa fa-user"></i>
            <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
        </span>
        <span>&nbsp;|&nbsp;</span>
        <span>
            <i class="fa fa-eye"></i>
            <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
        </span>
    </div>


            </div>
            

            
        </div>
    </div>
    

    <div class="footer-copyright pink-link-context">
        <div class="container">
            © 2016 example.com, All rights reserved.
            <p class="right" style="margin-top: 0;">本博客由 <a href="https://hexo.io">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a></p>
        </div>
    </div>
</footer>


    <noscript>
    <div class="noscript">
        <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
    </div>
</noscript>
<div class="noscript">
    <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
</div>


<script src="/js/jquery.min.js"></script>
<script src="/js/materialize.min.js"></script>

<script>
    (function($) {
        $(document).ready(function() {
            // 隐藏禁用javascript（针对微信内置浏览器）的提示
            $('.noscript').hide();

            // 图片缩放效果
            var $imgs = $('img').not('.slider-image').not('.avatar-image').not('.carousel-image').not('.card-cover-image').not('.qrcode');

            // 给图片加上点击放大效果（materialbox插件）
            $imgs.addClass('materialboxed').each(function(i, el) {
                $(this).attr('data-caption', $(this).attr('alt') || ' ');
            }).materialbox();

            // 优化表格的显示
            $('table').each(function() {
                var $table = $(this);
                // 除去多行代码的情况
                if ($table.find('pre').length == 0) {
                    $table.addClass('responsive-table striped bordered');
                }
            });

            // 首页幻灯片
            $('.slider').slider({indicators: true, full_width: true, interval: 8000});

            $(".button-collapse").sideNav();
            $(".category-menu").sideNav();

            // 针对gallery post
            $('.carousel').carousel({full_width: true});
            $('.carousel-control.prev').click(function() {
                $('.carousel').carousel('prev');
            });
            $('.carousel-control.next').click(function() {
                $('.carousel').carousel('next');
            });

            // 文章目录
            $('article').not('.simple-article').find('h1').add('h2').add('h3').add('h4').add('h5').add('h6').scrollSpy();

            // 目录随屏幕滚动（防止目录过长越过footer）
            var $toc = $('.toc');
            var scrollTargetTop = 0;
            $(window).scroll(function() {
                var $activeLink = $toc.find('a.active.section');
                if ($(window).scrollTop() < 100) {
                    scrollTargetTop = 0;
                } else {
                    if ($activeLink[0]) {
                        scrollTargetTop = $activeLink.offset().top - $toc.offset().top;
                    }
                }
                $toc.css('top', '-' + scrollTargetTop + 'px');
            });

            // 修正文章目录的left-border颜色
            var color = $('.table-of-contents-text').css('color');
            $('.table-of-contents-link').css('border-left-color', color);

            // 针对移动端做的优化：FAB按钮点击一下收回
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                $('.fixed-action-btn').addClass('click-to-toggle');
            }
            // 回到顶部
            $('.btn-return-top').click(function() {
                $('body, html').animate({
                    scrollTop: 0
                }, 500);
            });

            // 重置读书页面的Tab标签页的颜色
            $('li.tab a').hover(function() {
                $(this).toggleClass('text-lighten-4');
            });
            $('.indicator').addClass('pink lighten-2');

            
            // 添加new标签
            $('.menu-reading').append('<span class="new badge pink"></span>');
            

            // 搜索功能
            $('.modal-trigger').leanModal({
                // 打开搜索框时自动聚焦
                ready: function() {
                    if ($('#search').is(":visible")) {
                        $('#search-input').focus();
                    }
                }
            });
            var searchXml = "search.xml";
            if (searchXml.length == 0) {
             	searchXml = "search.xml";
            }
            var searchPath = "/" + searchXml;
            initSearch(searchPath, 'search-input', 'search-result');
        });

        // 初始化搜索与匹配函数
        var initSearch = function(path, search_id, content_id) {
            'use strict';
            $.ajax({
                url: path,
                dataType: "xml",
                success: function(xmlResponse) {
                    // get the contents from search data
                    var datas = $("entry", xmlResponse).map(function() {
                        return {
                            title: $("title", this).text(),
                            content: $("content", this).text(),
                            url: $("url", this).text()
                        };
                    }).get();
                    var $input = document.getElementById(search_id);
                    var $resultContent = document.getElementById(content_id);
                    $input.addEventListener('input', function() {
                        var str = '<ul class=\"search-result-list\">';
                        var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                        $resultContent.innerHTML = "";
                        if (this.value.trim().length <= 0) {
                            return;
                        }
                        // perform local searching
                        datas.forEach(function(data) {
                            var isMatch = true;
                            var content_index = [];
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty titles and contents
                            if (data_title != '' && data_content != '') {
                                keywords.forEach(function(keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);
                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            }
                            // show search results
                            if (isMatch) {
                                keywords.forEach(function(keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    data_title = data_title.replace(regS, "<span class=\"search-keyword pink lighten-2\">" + keyword + "</span>");
                                });

                                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 100 characters
                                    var start = first_occur - 20;
                                    var end = first_occur + 80;
                                    if (start < 0) {
                                        start = 0;
                                    }
                                    if (start == 0) {
                                        end = 100;
                                    }
                                    if (end > content.length) {
                                        end = content.length;
                                    }
                                    var match_content = content.substring(start, end);
                                    // highlight all keywords
                                    keywords.forEach(function(keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, "<span class=\"search-keyword pink lighten-2\">" + keyword + "</span>");
                                    });

                                    str += "<p class=\"search-result\">..." + match_content + "...</p>"
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        $resultContent.innerHTML = str;
                    });
                }
            });
        }
    })(jQuery);
</script>


<script src="/js/prettify.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("pre").addClass("prettyprint");
        prettyPrint();
    });
</script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script type="text/javascript" async
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



</body>
</html>
