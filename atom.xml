<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cxsmarkchan的博客</title>
  <subtitle>cxsmarkchan的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cxsmarkchan.github.com/"/>
  <updated>2016-04-17T16:44:59.317Z</updated>
  <id>http://cxsmarkchan.github.com/</id>
  
  <author>
    <name>cxsmarkchan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux源码分析：schedule进程调度</title>
    <link href="http://cxsmarkchan.github.com/2016/04/18/linux-schedule/"/>
    <id>http://cxsmarkchan.github.com/2016/04/18/linux-schedule/</id>
    <published>2016-04-17T16:44:59.000Z</published>
    <updated>2016-04-17T16:44:59.317Z</updated>
    
    <content type="html">&lt;p&gt;schedule是linux中的一个内核函数，用于实现进程调度。该函数由内核线程在合适的时机调用，完成进程上下文的切换。本文从源码的角度分析了schedule函数的执行过程，尤其是进程上下文的切换过程。本文所分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;原创内容：cxsmarkchan 陈晓爽&lt;br&gt;转载请注明出处&lt;br&gt;&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:ustcX+USTC001+_/about&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;linux内核分析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-进程调度的基本方法&quot;&gt;&lt;a href=&quot;#1-进程调度的基本方法&quot; class=&quot;headerlink&quot; title=&quot;1 进程调度的基本方法&quot;&gt;&lt;/a&gt;1 进程调度的基本方法&lt;/h1&gt;&lt;p&gt;进程调度是操作系统的核心部分，操作系统的大多数行为，都可以概括为“从一个进程切换到另一个进程”。进程调度的时候，通常需要如下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择下一个要调度的进程&lt;/li&gt;
&lt;li&gt;保存当前进程的上下文&lt;/li&gt;
&lt;li&gt;切换到下一个进程的上下文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;linux系统在很多位置都会调用schedule函数，典型的调用场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统进行常规的进程调度&lt;/li&gt;
&lt;li&gt;在系统调用或其他中断的时候，会允许进行进程调度&lt;/li&gt;
&lt;li&gt;内核线程主动进行进程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-schedule函数的执行过程&quot;&gt;&lt;a href=&quot;#2-schedule函数的执行过程&quot; class=&quot;headerlink&quot; title=&quot;2 schedule函数的执行过程&quot;&gt;&lt;/a&gt;2 schedule函数的执行过程&lt;/h1&gt;&lt;h2 id=&quot;2-1-schedule函数&quot;&gt;&lt;a href=&quot;#2-1-schedule函数&quot; class=&quot;headerlink&quot; title=&quot;2.1 schedule函数&quot;&gt;&lt;/a&gt;2.1 schedule函数&lt;/h2&gt;&lt;p&gt;schedule函数定义在&lt;code&gt;kernel/sched/core.c&lt;/code&gt;中，其定义如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;asmlinkage __visible &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __&lt;span class=&quot;function&quot;&gt;sched &lt;span class=&quot;title&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *tsk = current;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sched_submit_work(tsk);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	__schedule();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见其最主要的内容是调用了&lt;code&gt;__schedule&lt;/code&gt;函数。&lt;/p&gt;
&lt;h2 id=&quot;2-2-schedule函数&quot;&gt;&lt;a href=&quot;#2-2-schedule函数&quot; class=&quot;headerlink&quot; title=&quot;2.2 __schedule函数&quot;&gt;&lt;/a&gt;2.2 __schedule函数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;__schedule&lt;/code&gt;函数执行了所有的进程调度工作。其主要功能为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取当前进程和下一个进程的进程控制块&lt;/li&gt;
&lt;li&gt;判断当前进程和下一个进程是否相同，如果不同，则调用&lt;code&gt;switch_context&lt;/code&gt;函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;__schedule&lt;/code&gt;函数的重要代码如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __sched __schedule(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *prev, *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; *switch_count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; rq *rq;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cpu;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;need_resched:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    preempt_disable();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cpu = smp_processor_id();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rq = cpu_rq(cpu);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	prev = rq-&amp;gt;curr; &lt;span class=&quot;comment&quot;&gt;//获取了当前进程的进程控制块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	next = pick_next_task(rq, prev); &lt;span class=&quot;comment&quot;&gt;//获取了下一个进程的进程控制块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	clear_tsk_need_resched(prev);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	clear_preempt_need_resched();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rq-&amp;gt;skip_clock_update = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (likely(prev != next)) &amp;#123; &lt;span class=&quot;comment&quot;&gt;//判断当前进程和下一个进程是否相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		rq-&amp;gt;nr_switches++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		rq-&amp;gt;curr = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		++*switch_count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		context_switch(rq, prev, next); &lt;span class=&quot;comment&quot;&gt;//切换进程上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		cpu = smp_processor_id();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		rq = cpu_rq(cpu);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		raw_spin_unlock_irq(&amp;amp;rq-&amp;gt;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	post_schedule(rq);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sched_preempt_enable_no_resched();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-3-pick-next-task函数&quot;&gt;&lt;a href=&quot;#2-3-pick-next-task函数&quot; class=&quot;headerlink&quot; title=&quot;2.3 pick_next_task函数&quot;&gt;&lt;/a&gt;2.3 pick_next_task函数&lt;/h2&gt;&lt;p&gt;pick_next_task函数位于&lt;code&gt;kernel/sched/core.c&lt;/code&gt;，其功能为获取下一个进程的进程控制块。其源码如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;pick_next_task&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; rq *rq, &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *prev)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; sched_class *&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; = &amp;amp;fair_sched_class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (likely(prev-&amp;gt;sched_class == &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		   rq-&amp;gt;nr_running == rq-&amp;gt;cfs.h_nr_running)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p = fair_sched_class.pick_next_task(rq, prev); &lt;span class=&quot;comment&quot;&gt;//进程调度算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (unlikely(p == RETRY_TASK))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; again;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;/* assumes fair_sched_class-&amp;gt;next == idle_sched_class */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (unlikely(!p))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p = idle_sched_class.pick_next_task(rq, prev); &lt;span class=&quot;comment&quot;&gt;//进程调度算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;again:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for_each_class(&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p = &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;-&amp;gt;pick_next_task(rq, prev); &lt;span class=&quot;comment&quot;&gt;//进程调度算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (unlikely(p == RETRY_TASK))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; again;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	BUG(); &lt;span class=&quot;comment&quot;&gt;/* the idle class will always have a runnable task */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见，该函数中3次调用了名为pick_next_task的函数。事实上，这3个pick_next_task均为函数指针，指向了3个不同的函数。也就是说，在不同的情况下，linux会选择不同的算法来获取下一个要执行的进程。&lt;/p&gt;
&lt;h2 id=&quot;2-4-context-switch函数和switch-to函数&quot;&gt;&lt;a href=&quot;#2-4-context-switch函数和switch-to函数&quot; class=&quot;headerlink&quot; title=&quot;2.4 context_switch函数和switch_to函数&quot;&gt;&lt;/a&gt;2.4 context_switch函数和switch_to函数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;context_switch&lt;/code&gt;函数位于&lt;code&gt;kernel/sched/core.c&lt;/code&gt;，其主要功能是执行进程调度。此处不再列举其源码，因为在源码中，最重要的一条语句即为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;switch_to(prev, next, prev);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该语句的任务是执行进程上下文的切换。对于不同的CPU指令集，进程上下文切换的步骤也不同，因此&lt;code&gt;switch_to&lt;/code&gt;是存放在&lt;code&gt;arch&lt;/code&gt;目录中的。对于x86指令集，该函数位于&lt;code&gt;arch/x86/include/asm/switch_to.h&lt;/code&gt;，其源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; switch_to(prev, next, last)					\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do &amp;#123;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	unsigned long ebx, ecx, edx, esi, edi;				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;span class=&quot;string&quot;&gt;&quot;pushfl\n\t&quot;&lt;/span&gt;		&lt;span class=&quot;comment&quot;&gt;/* 保存进程标志 */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;pushl %%ebp\n\t&quot;&lt;/span&gt;		&lt;span class=&quot;comment&quot;&gt;/* 保存prev进程的堆栈底端   */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;movl %%esp,%[prev_sp]\n\t&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 将prev进程的堆栈信息存入prev的进程控制块中   */&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;movl %[next_sp],%%esp\n\t&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 从next进程的进程控制块中调出堆栈位置信息   */&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;movl $1f,%[prev_ip]\n\t&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 将$1位置存入prev的进程控制块，作为下次调用的起点   */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;pushl %[next_ip]\n\t&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 将next进程的当前语句压栈   */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     __switch_canary					\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;jmp __switch_to\n&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 跳转到__switch_to函数，由于没有执行call语句，因此堆栈中的返回位置是next_ip  */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;comment&quot;&gt;/* 从__switch_to中返回时，进程上下文已切换至next进程，并执行$1位置 */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;1:\t&quot;&lt;/span&gt;					&lt;span class=&quot;comment&quot;&gt;/* $1位置，进程继续执行的位置 */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;popl %%ebp\n\t&quot;&lt;/span&gt;		&lt;span class=&quot;comment&quot;&gt;/* 弹出next进程的堆栈底端   */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;popfl\n&quot;&lt;/span&gt;			&lt;span class=&quot;comment&quot;&gt;/* 恢复进程标志 */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;comment&quot;&gt;/* output parameters */&lt;/span&gt;				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     : [prev_sp] &lt;span class=&quot;string&quot;&gt;&quot;=m&quot;&lt;/span&gt; (prev-&amp;gt;thread.sp),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       [prev_ip] &lt;span class=&quot;string&quot;&gt;&quot;=m&quot;&lt;/span&gt; (prev-&amp;gt;thread.ip),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;string&quot;&gt;&quot;=a&quot;&lt;/span&gt; (last),					\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;comment&quot;&gt;/* clobbered output registers: */&lt;/span&gt;		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;string&quot;&gt;&quot;=b&quot;&lt;/span&gt; (ebx), &lt;span class=&quot;string&quot;&gt;&quot;=c&quot;&lt;/span&gt; (ecx), &lt;span class=&quot;string&quot;&gt;&quot;=d&quot;&lt;/span&gt; (edx),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;string&quot;&gt;&quot;=S&quot;&lt;/span&gt; (esi), &lt;span class=&quot;string&quot;&gt;&quot;=D&quot;&lt;/span&gt; (edi)				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       							\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       __switch_canary_oparam				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;comment&quot;&gt;/* input parameters: */&lt;/span&gt;				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     : [next_sp]  &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (next-&amp;gt;thread.sp),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       [next_ip]  &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (next-&amp;gt;thread.ip),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       							\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;comment&quot;&gt;/* regparm parameters for __switch_to(): */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       [prev]     &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; (prev),				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       [next]     &lt;span class=&quot;string&quot;&gt;&quot;d&quot;&lt;/span&gt; (next)				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       __switch_canary_iparam				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     : &lt;span class=&quot;comment&quot;&gt;/* reloaded segment registers */&lt;/span&gt;			\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;string&quot;&gt;&quot;memory&quot;&lt;/span&gt;);					\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段程序分为保存现场和恢复现场两部分。保存现场的内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;压栈保存flag&lt;/li&gt;
&lt;li&gt;压栈保存ebp信息&lt;/li&gt;
&lt;li&gt;将sp存入进程控制块的sp中&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;$1&lt;/code&gt;存入进程控制块的ip中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里值得注意的是：保存ip信息时，并没有把当前的ip存入进程控制块，这是因为，下次恢复现场的时候，并不希望从当前ip处执行，而是希望从当前ip的后面几句，即&lt;code&gt;$1&lt;/code&gt;处开始执行。&lt;/p&gt;
&lt;p&gt;恢复现场的内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从进程控制块中取出sp&lt;/li&gt;
&lt;li&gt;从进程控制块中取出ip并压栈&lt;/li&gt;
&lt;li&gt;用jmp而不是call调用__switch_to函数（用call时会将当前ip压栈，这并不是我们期望的，因为next_ip已经压栈了），在函数返回时的ret将栈顶的ip弹出到程序指针处&lt;/li&gt;
&lt;li&gt;弹栈恢复ebp信息&lt;/li&gt;
&lt;li&gt;弹栈恢复flag信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;理解这段程序时，应该注意：next进程在上一次切换时，也执行了保存现场的语句，因此next进程的现场和prev进程的现场在结构上是相同的。&lt;/p&gt;
&lt;h1 id=&quot;3-小结&quot;&gt;&lt;a href=&quot;#3-小结&quot; class=&quot;headerlink&quot; title=&quot;3 小结&quot;&gt;&lt;/a&gt;3 小结&lt;/h1&gt;&lt;p&gt;在linux系统中，进程调度是很重要的一部分。linux系统的一般执行过程即为“从一个进程切换到另一个进程”。进程切换通过调用schedule函数来完成，其中最主要的内容即为进程上下文的切换。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;schedule是linux中的一个内核函数，用于实现进程调度。该函数由内核线程在合适的时机调用，完成进程上下文的切换。本文从源码的角度分析了schedule函数的执行过程，尤其是进程上下文的切换过程。本文所分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/categories/linux/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="进程" scheme="http://cxsmarkchan.github.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="schedule" scheme="http://cxsmarkchan.github.com/tags/schedule/"/>
    
  </entry>
  
  <entry>
    <title>linux源码分析：execve加载可执行文件</title>
    <link href="http://cxsmarkchan.github.com/2016/04/10/linux-execve/"/>
    <id>http://cxsmarkchan.github.com/2016/04/10/linux-execve/</id>
    <published>2016-04-09T18:29:42.000Z</published>
    <updated>2016-04-09T18:29:42.137Z</updated>
    
    <content type="html">&lt;p&gt;execve是linux中一个重要的系统调用，它用于将一个可执行文件加载如内存中并执行。在执行shell命令时，就会调用execve函数。有意思的是，execve并未创建新的进程，而是会把当前进程覆盖。本文分析execve的实现过程，以加深对linux可执行文件加载过程的理解。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容： cxsmarkchan 陈晓爽&lt;br&gt;转载请注明出处&lt;br&gt;&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:ustcX+USTC001+_/about&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux内核分析&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-execve的使用方法&quot;&gt;&lt;a href=&quot;#1-execve的使用方法&quot; class=&quot;headerlink&quot; title=&quot;1 execve的使用方法&quot;&gt;&lt;/a&gt;1 execve的使用方法&lt;/h1&gt;&lt;p&gt;execve的调用格式如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * filename,&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; argv[ ],&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; envp[ ])&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;按照linux一切皆文件的思想，加载可执行程序，实际上是把一个二进制文件加载入内存。其中，&lt;code&gt;filename&lt;/code&gt;为可执行文件名，&lt;code&gt;argv&lt;/code&gt;为输入的参数，&lt;code&gt;envp&lt;/code&gt;为环境参数。在执行shell命令时，我们只需输入filename和argv，而envp则由系统自动赋值。&lt;br&gt;为了演示execve的使用，首先看下面一段C代码：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* str[] = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;ls&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execve(&lt;span class=&quot;string&quot;&gt;&quot;/bin/ls&quot;&lt;/span&gt;, str, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ls done!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码中用execve调用了linux的ls进程，用于显示当前目录下的文件。假设当前目录下有&lt;code&gt;test.cpp&lt;/code&gt;和&lt;code&gt;a.out&lt;/code&gt;两个文件，猜一下这段程序的运行结果是什么呢？从直觉上看，似乎应该是这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test.cpp a.out&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls done!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但实际上，运行结果是这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test.cpp a.out&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行完execve后，那句printf语句为什么没有被执行呢？这正是execve的神奇之处：它没有创建新进程，而是用新加载的可执行文件把当前进程覆盖了！因此，执行完execve后，printf语句早已不存在。&lt;br&gt;因此，调用execve的时候，我们通常用如下程序，先fork一个子进程，并在子进程中加载可执行文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char* str[] = &amp;#123;&amp;quot;ls&amp;quot;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int pid = fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(pid == 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        execve(&amp;quot;/bin/ls&amp;quot;, str, NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(NULL); // 等待子进程返回&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;ls done!\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段程序就可以得到预期的输出结果，即先输出ls的结果，再输出&lt;code&gt;ls done!&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;2-execve源码分析&quot;&gt;&lt;a href=&quot;#2-execve源码分析&quot; class=&quot;headerlink&quot; title=&quot;2 execve源码分析&quot;&gt;&lt;/a&gt;2 execve源码分析&lt;/h1&gt;&lt;h2 id=&quot;2-1-从execve到exec-binprm&quot;&gt;&lt;a href=&quot;#2-1-从execve到exec-binprm&quot; class=&quot;headerlink&quot; title=&quot;2.1 从execve到exec_binprm&quot;&gt;&lt;/a&gt;2.1 从execve到exec_binprm&lt;/h2&gt;&lt;p&gt;execve位于内核源码的&lt;code&gt;fs/exec.c&lt;/code&gt;，其定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SYSCALL_DEFINE3(execve,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *, filename,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __user *, argv,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __user *, envp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; do_execve(getname(filename), argv, envp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;do_execve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; filename *filename,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __user *__argv,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __user *__envp)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_arg_ptr argv = &amp;#123; .ptr.native = __argv &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_arg_ptr envp = &amp;#123; .ptr.native = __envp &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; do_execve_common(filename, argv, envp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见sys_execve函数调用了do_execve函数，而后者又调用了do_execve_common函数。do_execve_common函数中同样定义于&lt;code&gt;fs/exec.c&lt;/code&gt;中，它包含了execve的主体部分，代码较长，我们只分析其中的主干部分：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;do_execve_common&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; filename *filename,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_arg_ptr argv,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_arg_ptr envp)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; linux_binprm *bprm; &lt;span class=&quot;comment&quot;&gt;//bprm用于维护程序执行的相关参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; file *file;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm = kzalloc(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(*bprm), GFP_KERNEL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = prepare_bprm_creds(bprm); &lt;span class=&quot;comment&quot;&gt;//分配creds结构体，处理锁信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	check_unsafe_exec(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    current-&amp;gt;in_execve = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//表明当前进程正在执行新程序，这个在进程调度中有意义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	file = do_open_exec(filename); &lt;span class=&quot;comment&quot;&gt;//打开文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sched_exec(); &lt;span class=&quot;comment&quot;&gt;//进程调度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;file = file;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;filename = bprm-&amp;gt;interp = filename-&amp;gt;name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = bprm_mm_init(bprm); &lt;span class=&quot;comment&quot;&gt;//初始化内存映射&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//以下内容为填充bprm，录入输入参数、环境参数等信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;argc = count(argv, MAX_ARG_STRINGS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;envc = count(envp, MAX_ARG_STRINGS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = prepare_binprm(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = copy_strings_kernel(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &amp;amp;bprm-&amp;gt;filename, bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;exec = bprm-&amp;gt;p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = copy_strings(bprm-&amp;gt;envc, envp, bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = copy_strings(bprm-&amp;gt;argc, argv, bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//装载程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retval = exec_binprm(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//还原信息和释放内存等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    current-&amp;gt;in_execve = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    free_bprm(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;在do_execve_common中，最重要的工作是构建bprm结构体&lt;/strong&gt;。bprm结构体中包含了装载应用程序需要的所有信息，这些信息正是在do_execve_common中录入。这里应该重点关注bprm-&amp;gt;p，它代表了应用程序堆栈的当前位置。我们知道，在调用一个应用程序时，相关参数实际上是main函数的参数，而参数的传入方式是通过堆栈传递。因此，在初始化应用程序的时候，必须首先把参数压栈。这个操作是在copy_strings_kernel和copy_strings函数中完成的(这些函数中会修改bprm-&amp;gt;p)。当这些操作完成后，bprm-&amp;gt;p已经指向了当前的堆栈顶端，因此装载可执行程序时，只需要把堆栈指向bprm-&amp;gt;p，即可顺利执行。&lt;/p&gt;
&lt;p&gt;构建完bprm后，do_execve_common调用了exec_binprm函数，装载应用程序。该函数定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// exec_binprm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// position: fs/exec.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static int exec_binprm(struct linux_binprm *bprm)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pid_t old_pid, old_vpid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	/* Need to fetch pid before load_binary changes it */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	old_pid = current-&amp;gt;pid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rcu_read_lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	old_vpid = task_pid_nr_ns(current, task_active_pid_ns(current-&amp;gt;parent));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rcu_read_unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ret = search_binary_handler(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (ret &amp;gt;= 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		audit_bprm(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		trace_sched_process_exec(current, old_pid, bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ptrace_event(PTRACE_EVENT_EXEC, old_vpid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		proc_exec_connector(current);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中最关键的语句是search_binary_handler，其功能是根据可执行文件的格式，查找相应的处理程序。&lt;/strong&gt;其定义如下(只列举了重要语句)：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;search_binary_handler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; linux_binprm *bprm)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; linux_binfmt *fmt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = security_bprm_check(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	read_lock(&amp;amp;binfmt_lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 查找合适的处理程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	list_for_each_entry(fmt, &amp;amp;formats, lh) &amp;#123; &lt;span class=&quot;comment&quot;&gt;//遍历formats列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!try_module_get(fmt-&amp;gt;module)) &lt;span class=&quot;comment&quot;&gt;//判断文件格式是否匹配&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		read_unlock(&amp;amp;binfmt_lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bprm-&amp;gt;recursion_depth++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		retval = fmt-&amp;gt;load_binary(bprm); &lt;span class=&quot;comment&quot;&gt;//处理程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		put_binfmt(fmt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bprm-&amp;gt;recursion_depth--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	read_unlock(&amp;amp;binfmt_lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该函数中用到了list_for_each_entry宏，这里不分析该宏的具体实现，只需知道它用于遍历formats中所有的列表项。formats列表中的每一项都是一个linux_binfmt结构体，代表了一种文件格式。每个变量中有一个名为load_binary的函数指针，指向相应的加载函数。例如，linux中最常用的ELF格式文件，其对应的加载函数即为load_elf_binary。这种实现方式类似于C++中的多态，也比较灵活，但内核实现需要借助很多宏，理解起来不如C++方便。&lt;br&gt;&lt;strong&gt;在search_binary_handler中，formats被遍历，当找到匹配的文件格式时，load_binary函数即被调用。&lt;/strong&gt;接下来，我们只分析load_elf_binary的源码。&lt;/p&gt;
&lt;h2 id=&quot;2-2-load-elf-binary&quot;&gt;&lt;a href=&quot;#2-2-load-elf-binary&quot; class=&quot;headerlink&quot; title=&quot;2.2 load_elf_binary&quot;&gt;&lt;/a&gt;2.2 load_elf_binary&lt;/h2&gt;&lt;p&gt;load_elf_binary位于&lt;code&gt;fs/binfmt_elf.c&lt;/code&gt;，其代码很长，因为它需要对ELF格式的二进制文件进行解析。我们同样只看其中最主干的部分：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;load_elf_binary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; linux_binprm *bprm)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//大量变量定义，此处未完全列举&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * elf_interpreter = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; elf_entry; &lt;span class=&quot;comment&quot;&gt;//进程入口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pt_regs *regs = current_pt_regs(); &lt;span class=&quot;comment&quot;&gt;//当前的进程信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; elfhdr elf_ex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; elfhdr interp_elf_ex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; *loc; &lt;span class=&quot;comment&quot;&gt;//进程执行信息，包括进程入口等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;////////////////////////////////////////////&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//文件解析工作，此处省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;////////////////////////////////////////////&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (elf_interpreter) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 动态链接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; interp_map_addr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		elf_entry = load_elf_interp(&amp;amp;loc-&amp;gt;interp_elf_ex,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					    interpreter,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					    &amp;amp;interp_map_addr,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					    load_bias);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		reloc_func_desc = interp_load_addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		allow_write_access(interpreter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fput(interpreter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		kfree(elf_interpreter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 静态链接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		elf_entry = loc-&amp;gt;elf_ex.e_entry;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	kfree(elf_phdata);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	set_binfmt(&amp;amp;elf_format);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/////////////////////////////////////////////////////////&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//此处省略了设置内存映射的相关内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/////////////////////////////////////////////////////////&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	start_thread(regs, elf_entry, bprm-&amp;gt;p); &lt;span class=&quot;comment&quot;&gt;//启动进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;该函数主要做了3部分工作：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;把可执行文件读入内存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据读入的elf文件信息，设置可执行文件的入口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动线程&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上述代码可见，在设置可执行文件入口的时候，需要根据程序是否有动态链接行为，决定进程的入口位置，此处不再展开说明。&lt;/p&gt;
&lt;h2 id=&quot;2-3-start-thread&quot;&gt;&lt;a href=&quot;#2-3-start-thread&quot; class=&quot;headerlink&quot; title=&quot;2.3 start_thread&quot;&gt;&lt;/a&gt;2.3 start_thread&lt;/h2&gt;&lt;p&gt;经过一番曲折，终于到了execve程序的末尾。上一节中load_elf_binary最后有这么一句话：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;start_thread(regs, elf_entry, bprm-&amp;gt;p);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个语句即为启动新加载的程序了。在x86 32位系统中，start_thread定义在&lt;code&gt;arch/x86/kernel/process_32.c&lt;/code&gt;中，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;start_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pt_regs *regs, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; new_ip, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; new_sp)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	set_user_gs(regs, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;fs		= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;ds		= __USER_DS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;es		= __USER_DS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;ss		= __USER_DS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;cs		= __USER_CS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;ip		= new_ip;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;sp		= new_sp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;flags		= X86_EFLAGS_IF;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	set_thread_flag(TIF_NOTIFY_RESUME);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意我们传入的3个参数，第1个参数regs即为当前进程的注册信息，在load_elf_binary中定义。第2个参数new_ip是入口指令位置，在load_elf_binary中，由elf_entry指定。第3个参数new_sp是堆栈位置，传入参数为bprm-&amp;gt;p，这个信息很早的时候，在do_execve_common函数中即设置完毕。有了这3个参数，start_thread可以顺利执行，可执行程序也就加载完毕。&lt;/p&gt;
&lt;h1 id=&quot;3-小结&quot;&gt;&lt;a href=&quot;#3-小结&quot; class=&quot;headerlink&quot; title=&quot;3 小结&quot;&gt;&lt;/a&gt;3 小结&lt;/h1&gt;&lt;p&gt;linux在装载和启动一个可执行程序的时候，主要做了如下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建linux_binprm结构体，装载文件名、参数等信息，并完成堆栈信息的记录。&lt;/li&gt;
&lt;li&gt;根据可执行文件的格式信息，查找相应的解析和加载程序。对于ELF程序，即为调用load_elf_binary函数。&lt;/li&gt;
&lt;li&gt;在load_binary函数中，设置可执行程序的入口指令位置，并调用start_kernel，装入新的ip和sp，完成可执行程序的启动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，execve是在当前进程（调用execve函数的进程）上加载可执行文件，加载完毕后，原进程即被覆盖。如果不希望被覆盖，应该用fork创建新进程，再调用execve函数。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;execve是linux中一个重要的系统调用，它用于将一个可执行文件加载如内存中并执行。在执行shell命令时，就会调用execve函数。有意思的是，execve并未创建新的进程，而是会把当前进程覆盖。本文分析execve的实现过程，以加深对linux可执行文件加载过程的理解。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot;&gt;这里&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/categories/linux/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="execve" scheme="http://cxsmarkchan.github.com/tags/execve/"/>
    
      <category term="进程" scheme="http://cxsmarkchan.github.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux源码分析：fork复制进程</title>
    <link href="http://cxsmarkchan.github.com/2016/04/03/linux-fork/"/>
    <id>http://cxsmarkchan.github.com/2016/04/03/linux-fork/</id>
    <published>2016-04-03T13:04:54.000Z</published>
    <updated>2016-04-04T04:41:01.901Z</updated>
    
    <content type="html">&lt;p&gt;fork函数是linux系统的一个API，用于将当前进程复制，并创建一个新的进程。本文从linux源码的角度分析fork的实现过程，并学习linux创建新进程的过程。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容：cxsmarkchan 陈晓爽&lt;br&gt;转载请注明出处&lt;br&gt;&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Linux内核分析》MOOC课程&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-fork函数&quot;&gt;&lt;a href=&quot;#1-fork函数&quot; class=&quot;headerlink&quot; title=&quot;1 fork函数&quot;&gt;&lt;/a&gt;1 fork函数&lt;/h1&gt;&lt;p&gt;在Linux系统下书写如下C语言代码：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid = fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed!&quot;&lt;/span&gt;\n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This is Child Process!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This is Parent Process!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样一段程序的执行结果如下（注意两条语句的执行顺序并不完全确定）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;This is Parent Process!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is Child Process!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有意思的事情是：两条输出语句被写在if-elseif-else语句的不同分支中，但输出时竟然两条语句均输出了！&lt;br&gt;这正是fork函数的作用：它把当前进程状态和相关数据都复制了一份，系统中有两个进程在运行。新生成的进程与原进程的状态完全相同，因此它也会“认为”自己调用了fork函数，并从fork()函数中返回。但是，两个进程的fork函数返回值并不相等。对于父进程，返回的pid是其子进程的pid。对于子进程，返回的pid则是0。因此，会出现两条输出语句。&lt;br&gt;接下来，我们会分析fork语句在linux源码中的实现。我们关心的重点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新进程的堆栈空间是如何分配的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新进程如何保证与原进程有相同的堆栈状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新进程的起始执行点如何确定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何使新进程的返回值和原进程不同**&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-fork的源码分析&quot;&gt;&lt;a href=&quot;#2-fork的源码分析&quot; class=&quot;headerlink&quot; title=&quot;2 fork的源码分析&quot;&gt;&lt;/a&gt;2 fork的源码分析&lt;/h1&gt;&lt;h2 id=&quot;2-1-linux的进程信息管理&quot;&gt;&lt;a href=&quot;#2-1-linux的进程信息管理&quot; class=&quot;headerlink&quot; title=&quot;2.1 linux的进程信息管理&quot;&gt;&lt;/a&gt;2.1 linux的进程信息管理&lt;/h2&gt;&lt;p&gt;linux系统为每个进程维护了一个task_struct类型的结构体变量，用于存储进程相关信息。task_struct结构定义于&lt;code&gt;include/linux/sched.h&lt;/code&gt;，其代码约400行，包含进程的id、当前状态、内存信息、文件系统信息等。这里我们仅关系以下内容：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid; &lt;span class=&quot;comment&quot;&gt;//进程id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_struct thread; &lt;span class=&quot;comment&quot;&gt;//进程当前状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，进程的id用于对进程进行唯一标识，进程的内核堆栈是操作系统为每个进程维护的一段空间（其内部包含用户堆栈和寄存器信息等），进程的当前状态则也是一个结构体，包含了进程的堆栈信息、当前运行位置、锁信息等。thread_struct在各种硬件环境中实现也不相同，在x86系统中，thread_struct定义于&lt;code&gt;arch/x86/include/asm/processor.h&lt;/code&gt;。下面列出我们关心的内容：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_struct&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sp; &lt;span class=&quot;comment&quot;&gt;//堆栈顶端&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ip; &lt;span class=&quot;comment&quot;&gt;//当前运行位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因此，在创建新进程的时候，也需要给新进程分配id，分配内核堆栈stack，并初始化进程状态thread（在fork函数中，初始化的新进程状态应该与原进程完全相同，除了fork函数的返回值）。&lt;/p&gt;
&lt;h2 id=&quot;2-2-fork调用的全过程&quot;&gt;&lt;a href=&quot;#2-2-fork调用的全过程&quot; class=&quot;headerlink&quot; title=&quot;2.2 fork调用的全过程&quot;&gt;&lt;/a&gt;2.2 fork调用的全过程&lt;/h2&gt;&lt;p&gt;fork函数并不是一个普通的函数，而是一个系统调用，而系统调用是一个软件中断，在fork函数的调用过程中（中断返回前），会生成两个进程，因此生成的两个进程都仍处在中断状态，需要从中断状态返回。调用fork函数的父进程从中断过程返回是可以理解的，只需经过恢复现场的工作就可以了。但新生成的子进程，如何保证其初始化在中断状态，并从中断状态中返回呢？进一步地，如何让两个进程的返回值不相等呢？&lt;br&gt;下面的图可以简要地说明这种情况：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-flowchart.jpg&quot; alt=&quot;fork调用示意图&quot;&gt;&lt;br&gt;在该图中可以看出，父进程仍然是正常的系统调用处理过程，但新建的新进程，则是复制了父进程的状态，并把当前语句设置在&lt;code&gt;ret_from_fork&lt;/code&gt;标签处，该标签处执行一些初始化语句后，就跳转到&lt;code&gt;syscall_exit_work&lt;/code&gt;处，退出中断状态。由于子进程和父进程的堆栈完全相同，因此返回的位置也完全相同。&lt;br&gt;而唯一不同的是两个进程的返回值，这一点的实现则是靠&lt;code&gt;ax&lt;/code&gt;寄存器。&lt;code&gt;ax&lt;/code&gt;寄存器中存储了系统调用的返回值，对于新进程来说，在&lt;code&gt;copy_thread&lt;/code&gt;函数中将新进程的&lt;code&gt;ax&lt;/code&gt;寄存器值设置为0，因此新进程的返回为0。&lt;br&gt;各个函数的位置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system_call: &lt;code&gt;arch/x86/kernel/entry_32.S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;sys_fork: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;do_fork: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy_process: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;dup_task_struct: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy_thread: &lt;code&gt;arch/x86/kernel/process_32.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ret_from_kernel: &lt;code&gt;arch/x86/kernel/entry_32.S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下会重点分析dup_task_struct和copy_thread函数，以及ret_from_kernel过程&lt;/p&gt;
&lt;h2 id=&quot;2-3-相关的函数分析&quot;&gt;&lt;a href=&quot;#2-3-相关的函数分析&quot; class=&quot;headerlink&quot; title=&quot;2.3 相关的函数分析&quot;&gt;&lt;/a&gt;2.3 相关的函数分析&lt;/h2&gt;&lt;h3 id=&quot;2-3-1-dup-task-struct：创建进程&quot;&gt;&lt;a href=&quot;#2-3-1-dup-task-struct：创建进程&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 dup_task_struct：创建进程&quot;&gt;&lt;/a&gt;2.3.1 dup_task_struct：创建进程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;dup_task_struct用于创建一个新的进程，并把当前进程的信息复制到新进程（注意当前进程的运行状态不是在这里复制）。&lt;/strong&gt;部分重要的源码和我的注释如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *&lt;span class=&quot;title&quot;&gt;dup_task_struct&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *orig)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *tsk; &lt;span class=&quot;comment&quot;&gt;//新进程的进程管理结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_info *ti; &lt;span class=&quot;comment&quot;&gt;//新进程的内核堆栈结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; node = tsk_fork_get_node(orig); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; err;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tsk = alloc_task_struct_node(node); &lt;span class=&quot;comment&quot;&gt;//分配进程管理结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!tsk)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ti = alloc_thread_info_node(tsk, node); &lt;span class=&quot;comment&quot;&gt;//开辟内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!ti)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; free_tsk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	err = arch_dup_task_struct(tsk, orig); &lt;span class=&quot;comment&quot;&gt;//把orig的内容拷贝给tsk&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; free_ti;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tsk-&amp;gt;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt; = ti; &lt;span class=&quot;comment&quot;&gt;//把内核堆栈赋给tsk&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	setup_thread_stack(tsk, orig); &lt;span class=&quot;comment&quot;&gt;//初始化内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tsk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;free_ti:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free_thread_info(ti);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;free_tsk:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free_task_struct(tsk);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-copy-thread：复制进程状态&quot;&gt;&lt;a href=&quot;#2-3-2-copy-thread：复制进程状态&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 copy_thread：复制进程状态&quot;&gt;&lt;/a&gt;2.3.2 copy_thread：复制进程状态&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;copy_thread用于把原进程的状态和堆栈拷贝到新进程，并设置返回值为0。&lt;/strong&gt;部分重要的源码和我的注释如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copy_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; clone_flags, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; sp,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; arg, &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pt_regs *childregs = task_pt_regs(p); &lt;span class=&quot;comment&quot;&gt;// 获取新进程的内核堆栈指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;thread.sp = (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;) childregs; &lt;span class=&quot;comment&quot;&gt;// 将新进程的堆栈设置为新分配的堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *childregs = *current_pt_regs(); &lt;span class=&quot;comment&quot;&gt;// 复制所有的内核堆栈信息，包括寄存器信息和堆栈信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    childregs-&amp;gt;ax = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 这句话把ax设置为0，因此新进程的系统调用返回值为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    childregs-&amp;gt;sp = sp; &lt;span class=&quot;comment&quot;&gt;//复制当前堆栈信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;thread.ip = (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;) ret_from_fork; &lt;span class=&quot;comment&quot;&gt;// 设置新进程的入口位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见，该函数执行完毕后，新进程的堆栈和入口都已经确定，新进程启动时将处在中断状态，而中断返回值为0.&lt;/p&gt;
&lt;h3 id=&quot;2-3-3-ret-from-fork：退出中断&quot;&gt;&lt;a href=&quot;#2-3-3-ret-from-fork：退出中断&quot; class=&quot;headerlink&quot; title=&quot;2.3.3 ret_from_fork：退出中断&quot;&gt;&lt;/a&gt;2.3.3 ret_from_fork：退出中断&lt;/h3&gt;&lt;p&gt;这是新进程的第一条语句，当进程调度把CPU控制权交给新进程时，就会从该处向下执行。相关内容如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ENTRY(ret_from_fork)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFI_STARTPROC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pushl_cfi %eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	call schedule_tail&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	GET_THREAD_INFO(%ebp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	popl_cfi %eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pushl_cfi $0x0202		# Reset kernel eflags&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	popfl_cfi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	jmp syscall_exit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFI_ENDPROC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;END(ret_from_fork)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中有一句&lt;code&gt;jmp syscall_exit&lt;/code&gt;，而&lt;code&gt;syscall_exit&lt;/code&gt;位于系统调用函数刚结束，正准备退出中断的位置。此时&lt;code&gt;ax&lt;/code&gt;寄存器中存储了系统调用的返回值，而新进程的堆栈已经和原进程完全相同，因此会和原进程在相同的位置返回。到这里，也就得到了我们在第1节看到的结果：子进程将进入&lt;code&gt;pid == 0&lt;/code&gt;的分支。&lt;/p&gt;
&lt;h1 id=&quot;3-用gdb跟踪fork&quot;&gt;&lt;a href=&quot;#3-用gdb跟踪fork&quot; class=&quot;headerlink&quot; title=&quot;3 用gdb跟踪fork&quot;&gt;&lt;/a&gt;3 用gdb跟踪fork&lt;/h1&gt;&lt;p&gt;本节中，我们用gdb跟踪fork函数，以验证我们前面的结论。这里的实验平台采用&lt;a href=&quot;https://shiyanlou.com/courses/195&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验楼Linux内核分析&lt;/a&gt;的第6个实验：分析linux内核创建一个新进程的过程。&lt;br&gt;进入实验平台，输入如下代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd LinuxKernel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm menu -rf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/mengning/menu.git权威指南&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd menu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv test_fork.c test.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make rootfs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;即可看到启动的实验系统，在系统中输入fork命令，则可以看到如下运行结果：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-process.jpg&quot; alt=&quot;实验系统fork&quot;&gt;&lt;br&gt;为了能够用gdb跟踪，输入如下命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd ../rootfs.img -s -S&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再重启一个窗口，输入如下命令：&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ~/LinuxKernel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;file linux-3.18.6/vmlinux&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target remote:1234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c &lt;span class=&quot;comment&quot;&gt;#让程序执行一步&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;^C &lt;span class=&quot;comment&quot;&gt;#中断程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;#设置断点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;_fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b copy_process&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b dup_task_struct&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b copy_thread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b ret_from_fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置以上断点后，在模拟系统的控制台下键入fork，就可以通过断点跟踪fork的执行过程。这里就不展示所有的截图了，大致如下图：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-break.jpg&quot; alt=&quot;断点跟踪&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;4-小结&quot;&gt;&lt;a href=&quot;#4-小结&quot; class=&quot;headerlink&quot; title=&quot;4 小结&quot;&gt;&lt;/a&gt;4 小结&lt;/h1&gt;&lt;p&gt;Linux调用fork复制一个新进程需要经过如下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入系统中断，调用sys_fork函数&lt;/li&gt;
&lt;li&gt;sys_fork调用do_fork函数&lt;/li&gt;
&lt;li&gt;do_fork调用copy_process函数&lt;/li&gt;
&lt;li&gt;copy_process调用dup_task_struct函数，将父进程的task_struct拷贝给子进程，并为子进程创建单独的进程控制块和内核堆栈空间。新的进程就在这里诞生了。&lt;/li&gt;
&lt;li&gt;copy_process调用copy_thread函数，把父进程的堆栈信息复制给子进程，并将ax寄存器设置为0。然后，子进程的入口地点被设置为&lt;code&gt;ret_from_fork&lt;/code&gt;标签。&lt;/li&gt;
&lt;li&gt;父进程的系统调用逐层返回，返回值为子进程的pid。&lt;/li&gt;
&lt;li&gt;子进程在获得CPU控制权时，会执行&lt;code&gt;ret_from_fork&lt;/code&gt;，而&lt;code&gt;ret_from_fork&lt;/code&gt;会跳转到&lt;code&gt;syscall_exit&lt;/code&gt;标签，退出中断。由于&lt;code&gt;ax&lt;/code&gt;设置为0，所以系统调用返回0。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;fork函数是linux系统的一个API，用于将当前进程复制，并创建一个新的进程。本文从linux源码的角度分析fork的实现过程，并学习linux创建新进程的过程。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/categories/linux/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="fork" scheme="http://cxsmarkchan.github.com/tags/fork/"/>
    
      <category term="进程创建" scheme="http://cxsmarkchan.github.com/tags/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用：32位和64位的区别</title>
    <link href="http://cxsmarkchan.github.com/2016/04/02/asm-syscall-64/"/>
    <id>http://cxsmarkchan.github.com/2016/04/02/asm-syscall-64/</id>
    <published>2016-04-02T02:45:20.000Z</published>
    <updated>2016-04-02T02:45:20.436Z</updated>
    
    <content type="html">&lt;p&gt;最近在学习系统调用，一段用asm内联汇编写的简单程序始终得不出正确的结果，后来了解到这是32位平台和64位平台的系统调用方法不同的原因。在此列出相关的程序和我的理解。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;原创内容：cxsmarkchan&lt;br&gt;转载请注明出处&lt;br&gt;首次发表于csdn：&lt;a href=&quot;http://blog.csdn.net/cxsmarkchan/article/details/50987222&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux asm系统调用：32位和64位的区别&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;程序代码和问题&quot;&gt;&lt;a href=&quot;#程序代码和问题&quot; class=&quot;headerlink&quot; title=&quot;程序代码和问题&quot;&gt;&lt;/a&gt;程序代码和问题&lt;/h1&gt;&lt;p&gt;首先看如下一段简单的C程序（&lt;code&gt;test.cpp&lt;/code&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[] = &lt;span class=&quot;string&quot;&gt;&quot;Hello\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	write(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, str, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段程序调用了write函数，其接口为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int write(int fd /*输出位置句柄*/, const char* src /*输出首地址*/， int len /*长度*/)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;fd为0则表示输出到控制台。因此上述程序的执行结果为：向控制台输出一个长度为6的字符串&lt;code&gt;&amp;quot;Hello\n&amp;quot;&lt;/code&gt;。&lt;br&gt;在控制台调用&lt;code&gt;gcc test.cpp&lt;/code&gt;，可以正确输出。&lt;br&gt;为了更好地理解在汇编代码下的系统调用过程，可把上述代码改写成内联汇编的格式（具体语法可参考上一篇博客：&lt;a href=&quot;http://cxsmarkchan.github.io/2016/04/01/asm-syscall&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用asm内联汇编实现系统调用&lt;/a&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_A.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char str[] = &amp;quot;Hello\n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&amp;quot;a&amp;quot;(4), &amp;quot;b&amp;quot;(0), &amp;quot;c&amp;quot;(str), &amp;quot;d&amp;quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，4是write函数的系统调用号，ebx/ecx/edx是系统调用的前三个参数。&lt;br&gt;&lt;strong&gt;然而，执行&lt;code&gt;gcc test_asm_A.cpp&lt;/code&gt;编译后，再运行程序，发现程序没有任何输出&lt;/strong&gt;。一个很奇怪的问题是，如果采用如下&lt;code&gt;test_asm_B.cpp&lt;/code&gt;的写法，则程序可以正常地输出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_B.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char *str = (char*)malloc(7 * sizeof(char));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	strcpy(str, &amp;quot;Hello\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&amp;quot;a&amp;quot;(4), &amp;quot;b&amp;quot;(0), &amp;quot;c&amp;quot;(str), &amp;quot;d&amp;quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两段代码唯一的区别，是&lt;code&gt;test_asm_A.cpp&lt;/code&gt;中的&lt;code&gt;str&lt;/code&gt;存储在栈空间，而&lt;code&gt;test_asm_B.cpp&lt;/code&gt;中的&lt;code&gt;str&lt;/code&gt;存储在堆空间。&lt;/strong&gt;&lt;br&gt;那么，为什么存储位置的不同会造成完全不同的结果呢？&lt;/p&gt;
&lt;h1 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;原因分析&quot;&gt;&lt;/a&gt;原因分析&lt;/h1&gt;&lt;p&gt;经过提醒，将上述代码用32位的方式编译，即&lt;code&gt;gcc test_asm_A.cpp -m32&lt;/code&gt;和&lt;code&gt;gcc test_asm_B.cpp -m32&lt;/code&gt;，可以发现两段代码都能正确输出。这说明，上述代码按32位编译，可以得到正确的结果。&lt;br&gt;如果没有&lt;code&gt;-m32&lt;/code&gt;标志，则gcc默认按照64位方式编译。32位和64位程序在编译时有如下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32位和64位程序的地址空间范围不同。&lt;/li&gt;
&lt;li&gt;32位和64位程序的系统调用号不同，如本例中的write，在32位系统中调用号为4，在64位系统中则为1。&lt;/li&gt;
&lt;li&gt;对于32位程序，应调用&lt;code&gt;int $0x80&lt;/code&gt;进入系统调用，将系统调用号传入&lt;code&gt;eax&lt;/code&gt;，各个参数按照&lt;code&gt;ebx&lt;/code&gt;、&lt;code&gt;ecx&lt;/code&gt;、&lt;code&gt;edx&lt;/code&gt;的顺序传递到寄存器中，系统调用返回值储存到&lt;code&gt;eax&lt;/code&gt;寄存器。&lt;/li&gt;
&lt;li&gt;对于64位程序，应调用&lt;code&gt;syscall&lt;/code&gt;进入系统调用，将系统调用号传入&lt;code&gt;rax&lt;/code&gt;，各个参数按照&lt;code&gt;rdi&lt;/code&gt;、&lt;code&gt;rsi&lt;/code&gt;、&lt;code&gt;rdx&lt;/code&gt;的顺序传递到寄存器中，系统调用返回值储存到&lt;code&gt;rax&lt;/code&gt;寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看上面两段代码，它们都是调用&lt;code&gt;int $0x80&lt;/code&gt;进入系统调用，却按照64位方式编译，则会出现如下不正常情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序的地址空间是64位地址空间。&lt;/li&gt;
&lt;li&gt;0x80号中断进入的是32位系统调用函数，因此仍按照32位的方式来解释系统调用，即所有寄存器只考虑低32位的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看程序中传入的各个参数，系统调用号（4），第1个和第3个参数（0和6）都是32位以内的，但是&lt;strong&gt;str的地址是64位地址，在0x80系统调用中只有低32位会被考虑。&lt;/strong&gt;&lt;br&gt;这样，&lt;code&gt;test_asm_A.cpp&lt;/code&gt;不能正确执行，而&lt;code&gt;test_asm_B.cpp&lt;/code&gt;可以正确执行的原因就很明确了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;test_asm_A.cpp&lt;/code&gt;中，str存储在栈空间中，而&lt;strong&gt;栈空间在系统的高位，只取低32位地址，得到的是错误地址。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;test_asm_B.cpp&lt;/code&gt;中，str存储在堆空间中，而&lt;strong&gt;堆空间在系统的低位开始，在这样一个小程序中，str地址的高32位为0，只有低32位存在非零值，因此不会出现截断错误。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，&lt;code&gt;test_asm_B.cpp&lt;/code&gt;正确执行只是一个假象。由于堆空间从低位开始，如果开辟空间过多，堆空间也进入高位的时候，这段代码同样可能出错。&lt;/p&gt;
&lt;h1 id=&quot;64位系统的系统调用代码&quot;&gt;&lt;a href=&quot;#64位系统的系统调用代码&quot; class=&quot;headerlink&quot; title=&quot;64位系统的系统调用代码&quot;&gt;&lt;/a&gt;64位系统的系统调用代码&lt;/h1&gt;&lt;p&gt;最后，给出64位系统下可正确输出的asm系统调用代码：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_C.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char str[] = &quot;Hello\n&quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//注意：64位系统调用中，write函数调用号为1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&quot;mov %2, %%rsi\n\t&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&quot;syscall&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&quot;a&quot;(1), &quot;D&quot;(0), &quot;b&quot;(str), &quot;d&quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习系统调用，一段用asm内联汇编写的简单程序始终得不出正确的结果，后来了解到这是32位平台和64位平台的系统调用方法不同的原因。在此列出相关的程序和我的理解。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="内核" scheme="http://cxsmarkchan.github.com/categories/linux/%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="asm" scheme="http://cxsmarkchan.github.com/tags/asm/"/>
    
      <category term="系统调用" scheme="http://cxsmarkchan.github.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="64位" scheme="http://cxsmarkchan.github.com/tags/64%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>用asm内联汇编实现系统调用</title>
    <link href="http://cxsmarkchan.github.com/2016/04/01/asm-syscall/"/>
    <id>http://cxsmarkchan.github.com/2016/04/01/asm-syscall/</id>
    <published>2016-04-01T08:23:12.000Z</published>
    <updated>2016-04-01T08:23:12.458Z</updated>
    
    <content type="html">&lt;p&gt;CPU运行状态被分为内核态和用户态。操作系统在内核态下运行，拥有所有计算机资源的操作权限。而一般的应用程序则在用户态下运行，它们不能直接操作底层的硬件设备。应用程序在需要使用硬件资源时，可通过系统调用（system call）切换到内核态。本文通过asm内联汇编，分析系统调用的全过程。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容：cxsmarkchan&lt;br&gt;转载请注明出处&lt;br&gt;首次发表于csdn：&lt;a href=&quot;http://blog.csdn.net/cxsmarkchan/article/details/50939769&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用asm内联汇编实现系统调用&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Linux内核分析》MOOC课程&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-系统调用的概念&quot;&gt;&lt;a href=&quot;#1-系统调用的概念&quot; class=&quot;headerlink&quot; title=&quot;1 系统调用的概念&quot;&gt;&lt;/a&gt;1 系统调用的概念&lt;/h1&gt;&lt;p&gt;下图是一个典型的系统调用图示：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160320231125982&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;从该函数可以看到，系统调用分成如下过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户态程序调用API函数&lt;code&gt;xyz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;xyz&lt;/code&gt;接口函数内部，通过中断号&lt;code&gt;0x80&lt;/code&gt;进入系统调用，此时CPU进入内核态。&lt;/li&gt;
&lt;li&gt;CPU开始执行中断处理程序，根据用户传入的信息（系统调用号和相关参数），执行相应的内核态函数，并返回结果。&lt;br&gt;这里有两个问题：&lt;/li&gt;
&lt;li&gt;内核态的切换是通过中断方式进入的，而产生中断时只能传入一个中断向量（即&lt;code&gt;0x80&lt;/code&gt;），而系统调用有大量的API函数，系统如何知道调用哪一个函数呢？&lt;/li&gt;
&lt;li&gt;有一些API函数带有参数，而系统调用并没有才有函数调用（&lt;code&gt;call&lt;/code&gt;）方式，那么参数如何传递到被调用函数？&lt;br&gt;答案是：在调用&lt;code&gt;int 0x80&lt;/code&gt;进入系统调用前，预先把系统调用号和相关参数存入指定的寄存器中。这样，系统调用函数只需要访问相应的寄存器，就可以获得所有的信息。&lt;br&gt;事实上，在进入系统调用前，首先需要将系统调用号传入&lt;code&gt;eax&lt;/code&gt;寄存器中，并将参数依次传入&lt;code&gt;ebx&lt;/code&gt;、&lt;code&gt;ecx&lt;/code&gt;、&lt;code&gt;edx&lt;/code&gt;、&lt;code&gt;esi&lt;/code&gt;、&lt;code&gt;edi&lt;/code&gt;、&lt;code&gt;ebp&lt;/code&gt;寄存器中。系统调用最多只能传入6个参数，如果参数多于6个，则需要将参数预存在内存中，然后将参数指针传入寄存器。系统调用结束后，&lt;code&gt;eax&lt;/code&gt;会被替换为系统调用返回值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-用asm实现系统调用的实例&quot;&gt;&lt;a href=&quot;#2-用asm实现系统调用的实例&quot; class=&quot;headerlink&quot; title=&quot;2 用asm实现系统调用的实例&quot;&gt;&lt;/a&gt;2 用asm实现系统调用的实例&lt;/h1&gt;&lt;p&gt;本文运行平台为&lt;a href=&quot;https://www.shiyanlou.com/courses/195&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验楼Linux内核分析&lt;/a&gt;的第4个实验，运行环境为linux系统。&lt;br&gt;为了验证系统调用的全过程，我们以exit函数为例，给出代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    switch(id)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case 0:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //用C语言的方式调用exit函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;C exit\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            exit(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //用内联汇编的方式调用exit函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;asm exit\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;mov $0, %%ebx\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;mov $0x1, %%eax\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;others\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;before return\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该函数中，首先输入参数id。如果id为0，则调用C代码的exit函数。如果id为1，则调用汇编代码的exit函数。如果id为其他值，则顺序执行至main函数结尾。&lt;br&gt;事实上，上文的代码采用C代码和内联汇编实现了等价的功能，即&lt;code&gt;exit(0)&lt;/code&gt;功能。可以分析一下内联汇编的工作方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mov $0, %ebx&lt;/code&gt;：exit函数的第1个参数（也是唯一一个参数）为0，按照寄存器顺序，应该放在&lt;code&gt;ebx&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov $0x1, %eax&lt;/code&gt;：exit函数的系统调用号为&lt;code&gt;0x1&lt;/code&gt;，因此把系统调用号放入&lt;code&gt;eax&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int 0x80&lt;/code&gt;：产生中断，中断号&lt;code&gt;0x80&lt;/code&gt;表示系统调用。&lt;br&gt;执行了以上3步，即为执行了exit(0)函数。程序的运行结果如下：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160320233359080&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;可见，输入0或1时，都没有输出&lt;code&gt;&amp;quot;before return&amp;quot;&lt;/code&gt;，说明exit被成功调用，程序提前退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;3-小结&quot;&gt;&lt;a href=&quot;#3-小结&quot; class=&quot;headerlink&quot; title=&quot;3 小结&quot;&gt;&lt;/a&gt;3 小结&lt;/h1&gt;&lt;p&gt;系统调用既保证了操作系统的安全运行，也方便了用户态程序使用系统资源。用内联汇编的方式处理系统调用，可以很清晰地看出系统调用的过程，以及系统调用的参数传递方式。系统调用通过寄存器传递参数，因此在进行系统调用前，通常还需要备份相关寄存器中的信息。不过，在内联汇编中，这个工作会被编译器代劳。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CPU运行状态被分为内核态和用户态。操作系统在内核态下运行，拥有所有计算机资源的操作权限。而一般的应用程序则在用户态下运行，它们不能直接操作底层的硬件设备。应用程序在需要使用硬件资源时，可通过系统调用（system call）切换到内核态。本文通过asm内联汇编，分析系统调用的全过程。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="内核" scheme="http://cxsmarkchan.github.com/categories/linux/%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://cxsmarkchan.github.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编" scheme="http://cxsmarkchan.github.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="asm" scheme="http://cxsmarkchan.github.com/tags/asm/"/>
    
      <category term="系统调用" scheme="http://cxsmarkchan.github.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://cxsmarkchan.github.com/2016/03/30/firstblog/"/>
    <id>http://cxsmarkchan.github.com/2016/03/30/firstblog/</id>
    <published>2016-03-29T16:27:55.000Z</published>
    <updated>2016-03-30T15:14:05.555Z</updated>
    
    <content type="html">&lt;p&gt;&amp;emsp;&amp;emsp;博士入学已经一年半了，走过不少弯路，也算有一些成长。一直想抽时间做个博客，记录自己的学习和科研生活，最近终于付诸行动。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;电气工程是一个和计算机结合紧密的专业，我在做电力系统方向的科研时，也常常需要设计算法、编写程序。不过，直到去年，在董老师和浩哥的带领下，我才对码农的世界有了更多的了解，也越来越觉得自己如井底之蛙一般。因此，也希望更系统、更深入地学习计算机科学的知识，并将其融入到自己的科研中。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我会在这里记录自己的学习和思考，努力进步。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最后，希望自己能坚持下去^_^&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PS: 该博客用&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;搭建。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PPS: 之前在csdn上写过几篇博客，如果有空的话也会迁移过来。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;博士入学已经一年半了，走过不少弯路，也算有一些成长。一直想抽时间做个博客，记录自己的学习和科研生活，最近终于付诸行动。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://cxsmarkchan.github.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="博客" scheme="http://cxsmarkchan.github.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://cxsmarkchan.github.com/tags/hexo/"/>
    
  </entry>
  
</feed>
