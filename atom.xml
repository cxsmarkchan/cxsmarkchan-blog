<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cxsmarkchan的博客</title>
  <subtitle>cxsmarkchan的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cxsmarkchan.github.com/"/>
  <updated>2017-11-06T05:50:32.349Z</updated>
  <id>http://cxsmarkchan.github.com/</id>
  
  <author>
    <name>cxsmarkchan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一维搜索：0.618法与牛顿法</title>
    <link href="http://cxsmarkchan.github.com/2017/11/05/optimization-line-search/"/>
    <id>http://cxsmarkchan.github.com/2017/11/05/optimization-line-search/</id>
    <published>2017-11-06T02:35:25.000Z</published>
    <updated>2017-11-06T05:50:32.349Z</updated>
    
    <content type="html">&lt;p&gt;对于一般的优化问题，常见的解法是根据某个初始位置，确定一个搜索方向，把搜索问题暂时看作沿该方向的一维优化问题，再确定前进的步长。由此可见，一维的优化问题是最简单、也是最基本的优化问题。0.618法和牛顿法是两种具有代表性的方法。前者采用逐次试探的方式，不断逼近最优解，后者则把函数近似为二次函数，采用二次函数求极值的方法进行迭代求解。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、0-618法&quot;&gt;&lt;a href=&quot;#一、0-618法&quot; class=&quot;headerlink&quot; title=&quot;一、0.618法&quot;&gt;&lt;/a&gt;一、0.618法&lt;/h1&gt;&lt;p&gt;0.618法是&lt;strong&gt;试探法&lt;/strong&gt;的一种。考虑如下一维搜索问题：&lt;br&gt;\[&lt;br&gt;\min_x f(x)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;其中x是一维变量。我们此处仅讨论局部最优解的求解，因此不妨假设$f(x)$在某个局部$[a,b]$内是凸的。同时，可以假设$f(a)\leq f(b)$，并假设极小值点$x_0\in [a,b]$（这两个假设是为了简化论述，在实际算法中并不必要）。于是我们有$a\leq x_0 \leq b$，$f(x_0)\leq f(a) \leq f(b)$。&lt;/p&gt;
&lt;p&gt;由于$x_0$未知，为了缩小区间，我们在$[a,b]$中取两个点$x_1,x_2$（$x_1&amp;lt;x_2$），并计算$f(x_1)$和$f(x_2)$。此时可能出现两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f(x_1) \leq f(x_2)$，那么根据凸性必有$f(x_1)\leq f(x_2) \leq f(b)$，因此$(x_2,b]$内的所有点都不小于$f(x_2)$，因此可以被删去。而$[a,x_1]$和$[x_1,x_2]$中的点仍有可能是极值点。&lt;/li&gt;
&lt;li&gt;$f(x_1) \geq f(x_2)$，同理，可以删去$[a,x_1]$。&lt;br&gt;因此，根据两个端点$a,b$的函数值和两个中间点$x_1,x_2$的值，就可以将搜索区间从$[a,b]$缩小到$[a,x_2]$或$[x_1,b]$，这就是&lt;strong&gt;试探法&lt;/strong&gt;的基本思路。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，$x_1$和$x_2$应该如何选取呢？一种方法是尽量让区间缩小得更多。此时可以将$x_1$和$x_2$尽量靠近中点，这样可以保证每次都删去将近一半的区间。但一般来说，我们并不会采取这种方式。&lt;/p&gt;
&lt;p&gt;更常见的思路是：每次操作时都需要计算$f(x_1)$和$f(x_2)$，而这个计算有可能非常耗时。那么，有没有可能在下一次迭代中，继续用到上一次的计算结果，从而减少计算量呢？例如，第一次迭代中选取了$[a,b$区间中的$x_1,x_2$，计算发现$f(x_1) \leq f(x_2)$，从而可以删去$(x_2,b]$，保留$[a,x_2]$。注意到$x_1\in [a,x_2]$，因此在下一次迭代，选取两个中间点时，是否可以把$x_1$当做其中一个中间点？这样，就可以减少一半的计算量。&lt;/p&gt;
&lt;p&gt;如果采用这个思路，一个直接的问题是：能否保证每次迭代后区间长度都能稳定地减少？下面我们来分析这个问题。&lt;/p&gt;
&lt;p&gt;不妨假设所选区间为$[0,1]$，在选取中间点时，为了保证在两种情况下删除的区间大小一致，我们可以选择$x$和$1-x$作为中间点。假设$1-x&lt;x$，即$x&gt;0.5$，这样删去的区间大小即为$1-x$。&lt;/x$，即$x&gt;&lt;/p&gt;
&lt;p&gt;如果删去的是$(x,1]$，则留下了$[0,x]$，且$1-x\in [0, x]$。此时，删去的区间的长度是原区间的$1-x$倍。在选取中间点的时候，我们希望$1-x$是其中一个中间点，这就意味着如果$f(1-x)$大于另一个中间点的函数值，则删去的区间应为现在区间$[0,x]$的$1-x$倍，即$x(1-x)$。因此，有两种可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$1-x$为靠左的中间点，则$1-x=x(1-x)$，得出$x=1$，不符合$x$是中间点的要求；&lt;/li&gt;
&lt;li&gt;$1-x$为靠右的中间点，则$x-(1-x) = x(1-x)$,得到$x^2+x-1=0$，得到$x=\frac{\sqrt{5}-1}{2}\approx 0.618$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此可见，如果要保证每次删去的区间长度与原区间长度的比值一致，同时要求前一次迭代所求的中间点在后一次中能用上，中间点应该选在区间长度的0.618倍。此时，每次迭代，区间长度都会缩小为原区间长度的0.618倍。这种收敛方式我们一般称为&lt;strong&gt;线性收敛&lt;/strong&gt;，因为每次迭代后最优解的范围与前一次迭代的最优解范围呈线性关系（0.618倍）。除了线性收敛，还有些算法的收敛速度更快，牛顿法就是其中一种，可以达到&lt;strong&gt;二级收敛&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;二、牛顿法&quot;&gt;&lt;a href=&quot;#二、牛顿法&quot; class=&quot;headerlink&quot; title=&quot;二、牛顿法&quot;&gt;&lt;/a&gt;二、牛顿法&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;对于一般的优化问题，常见的解法是根据某个初始位置，确定一个搜索方向，把搜索问题暂时看作沿该方向的一维优化问题，再确定前进的步长。由此可见，一维的优化问题是最简单、也是最基本的优化问题。0.618法和牛顿法是两种具有代表性的方法。前者采用逐次试探的方式，不断逼近最优解，后者则把函数近似为二次函数，采用二次函数求极值的方法进行迭代求解。&lt;br&gt;
    
    </summary>
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/categories/%E4%BC%98%E5%8C%96/"/>
    
      <category term="算法" scheme="http://cxsmarkchan.github.com/categories/%E4%BC%98%E5%8C%96/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="优选法" scheme="http://cxsmarkchan.github.com/tags/%E4%BC%98%E9%80%89%E6%B3%95/"/>
    
      <category term="0.618" scheme="http://cxsmarkchan.github.com/tags/0-618/"/>
    
      <category term="黄金分割" scheme="http://cxsmarkchan.github.com/tags/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>对偶理论</title>
    <link href="http://cxsmarkchan.github.com/2017/11/01/optimization-dual/"/>
    <id>http://cxsmarkchan.github.com/2017/11/01/optimization-dual/</id>
    <published>2017-11-02T02:27:08.000Z</published>
    <updated>2017-11-03T05:19:55.281Z</updated>
    
    <content type="html">&lt;p&gt;对偶理论是优化理论中非常优美的部分，很多优化问题的求解都依赖对偶形式。强对偶定理保证了这种求解方法的正确性。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、拉格朗日函数和对偶问题&quot;&gt;&lt;a href=&quot;#一、拉格朗日函数和对偶问题&quot; class=&quot;headerlink&quot; title=&quot;一、拉格朗日函数和对偶问题&quot;&gt;&lt;/a&gt;一、拉格朗日函数和对偶问题&lt;/h1&gt;&lt;p&gt;考虑如下问题：&lt;br&gt;\[&lt;br&gt;p^*=\min f(x) \\&lt;br&gt;\text{s.t. } g(x) \leq 0, h(x)=0&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;其拉格朗日函数为：&lt;br&gt;\[&lt;br&gt;L(x,\lambda, \mu)=f(x) + \lambda^Tg(x) + \mu^Th(x)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;此时可以证明：&lt;br&gt;\[&lt;br&gt;\max_{\lambda\geq 0,\mu} L(x, \lambda, \mu) = \left\{&lt;br&gt;\begin{split}&lt;br&gt;f(x),&amp;amp;\text{if }g(x)\leq 0,h(x)=0 \\&lt;br&gt;+\infty,&amp;amp;\text{otherwise}&lt;br&gt;\end{split}&lt;br&gt;\right.&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;我们可以把原问题用拉格朗日函数表示：&lt;br&gt;\[&lt;br&gt;p^*=\min_x \max_{\lambda\geq 0,\mu} L(x,\lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;此时不必再显式考虑约束，这是因为约束不满足的时候，$L$的最大值是$+\infty$，因此不可能成为最优解。&lt;/p&gt;
&lt;p&gt;所谓&lt;strong&gt;对偶问题&lt;/strong&gt;，实际上是把原问题的min和max调换顺序：&lt;br&gt;\[&lt;br&gt;d^*=\max_{\lambda\geq 0, \mu} \min_x L(x, \lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;如果我们令$\theta(\lambda, \mu) = \min_x L(x, \lambda, \mu)$, 则对偶问题可以写成：&lt;br&gt;\[&lt;br&gt;d^*=\max_{\lambda\geq 0, \mu} \theta(\lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;h1 id=&quot;二、对偶问题的例子：线性规划&quot;&gt;&lt;a href=&quot;#二、对偶问题的例子：线性规划&quot; class=&quot;headerlink&quot; title=&quot;二、对偶问题的例子：线性规划&quot;&gt;&lt;/a&gt;二、对偶问题的例子：线性规划&lt;/h1&gt;&lt;p&gt;上述对偶问题的定义比较一般化，实际上，在具体问题中，对偶问题的形式可能会非常简单。我们以线性规划为例说明。&lt;/p&gt;
&lt;p&gt;考虑如下线性规划问题：&lt;br&gt;\[&lt;br&gt;p^*\min c^Tx \\&lt;br&gt;\text{s.t. } Ax\geq b&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;其拉格朗日函数为：&lt;br&gt;\[&lt;br&gt;L(x, \lambda, \mu) = c^Tx-\lambda^T(Ax-b) = (c-A^T\lambda)^Tx+\lambda^Tb&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;我们来计算$\theta(\lambda)$，显然有：&lt;br&gt;\[&lt;br&gt;\theta(\lambda) = \left\{&lt;br&gt;\begin{split}&lt;br&gt;\lambda^Tb,&amp;amp;\text{if }c-A^T\lambda=0 \\&lt;br&gt;-\infty,&amp;amp;\text{otherwise}&lt;br&gt;\end{split}&lt;br&gt;\right.&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;由于对偶问题可以表述为$d^*=\max_{\lambda\geq 0} \theta(\lambda)$，所以只有满足约束$c-A^T\lambda=0$的$\lambda$才可能作为候选解。因此，对偶问题可以表述为如下形式：&lt;br&gt;\[&lt;br&gt;d^*=\max_\lambda \lambda^Tb \\&lt;br&gt;\text{s.t. } \lambda\geq 0, c-A^T\lambda=0&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;由此可见，线性规划的对偶问题仍为线性规划。实际上，关于线性规划对偶问题的表述，有一套完整的规则，在任何一本线性规划的教材中均有提及，这里就不再赘述。&lt;/p&gt;
&lt;h1 id=&quot;三、弱对偶定理&quot;&gt;&lt;a href=&quot;#三、弱对偶定理&quot; class=&quot;headerlink&quot; title=&quot;三、弱对偶定理&quot;&gt;&lt;/a&gt;三、弱对偶定理&lt;/h1&gt;&lt;p&gt;弱对偶定理对于所有的优化问题均成立，该定理的表述非常简单：&lt;br&gt;\[&lt;br&gt;d^*\leq p^*&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;或者说：&lt;br&gt;\[&lt;br&gt;\max_{\lambda\geq 0,\mu} \min_x L(x, \lambda, \mu) \leq \min_x \max_{\lambda\geq 0, \mu} L(x, \lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;也就是说，一个最小化问题的对偶问题的最优解，永远小于该最小化问题的最优解。&lt;/p&gt;
&lt;p&gt;证明并不困难，注意到下列事实：&lt;br&gt;\[&lt;br&gt;\min_xL(x,\lambda,\mu) \leq L(x, \lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;两边同时对$\lambda$和$\mu$取最大值：&lt;br&gt;\[&lt;br&gt;d^*=\max_{\lambda\geq 0, \mu} \min_xL(x, \lambda, \mu) \leq \max_{\lambda\geq 0, \mu} L(x, \lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;由于左边已经是常数$d^*$，左侧恒不大于右侧，自然不大于右侧的最小值，也就是$p^*$，我们就得到了弱对偶定理。&lt;/p&gt;
&lt;h1 id=&quot;四、强对偶定理&quot;&gt;&lt;a href=&quot;#四、强对偶定理&quot; class=&quot;headerlink&quot; title=&quot;四、强对偶定理&quot;&gt;&lt;/a&gt;四、强对偶定理&lt;/h1&gt;&lt;p&gt;弱对偶定理在任何条件下都成立，但一般情况下，我们不能保证$d^*=p^*$。两者之间的距离$p^*-d^*$被称为对偶间隙。一个很自然的问题是，对偶间隙是否有可能为0？或者说，原问题和对偶问题的最优解有可能相等吗？这个问题非常重要，因为如果对偶间隙为零，我们就可以用对偶问题的最优解来代替原问题的最优解。有的时候，对偶问题比原问题更好求解。更重要地，在非线性优化中，我们常常需要终止条件，如果我们能同时求解原问题和对偶问题，当两者的解的间隙足够小，我们就可以认为最优解已经（近似）达到，从而终止算法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对偶理论是优化理论中非常优美的部分，很多优化问题的求解都依赖对偶形式。强对偶定理保证了这种求解方法的正确性。&lt;/p&gt;
    
    </summary>
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/categories/%E4%BC%98%E5%8C%96/"/>
    
      <category term="理论" scheme="http://cxsmarkchan.github.com/categories/%E4%BC%98%E5%8C%96/%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="对偶" scheme="http://cxsmarkchan.github.com/tags/%E5%AF%B9%E5%81%B6/"/>
    
      <category term="互补松弛" scheme="http://cxsmarkchan.github.com/tags/%E4%BA%92%E8%A1%A5%E6%9D%BE%E5%BC%9B/"/>
    
  </entry>
  
  <entry>
    <title>最优性条件：KKT</title>
    <link href="http://cxsmarkchan.github.com/2017/10/31/optimization-kkt/"/>
    <id>http://cxsmarkchan.github.com/2017/10/31/optimization-kkt/</id>
    <published>2017-10-31T04:17:22.000Z</published>
    <updated>2017-10-31T19:01:04.936Z</updated>
    
    <content type="html">&lt;p&gt;在最优性判别中，基于导数的方法是一种相当有效的方法。对于无约束优化，可以直接利用一阶导数作为必要性判据，利用二阶导数作为充分性判据。这种方法可以推广到约束优化中，也就是著名的KKT条件。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、无约束优化的判据&quot;&gt;&lt;a href=&quot;#一、无约束优化的判据&quot; class=&quot;headerlink&quot; title=&quot;一、无约束优化的判据&quot;&gt;&lt;/a&gt;一、无约束优化的判据&lt;/h1&gt;&lt;p&gt;考虑一维的无约束优化问题$\min_x f(x)$，如果我们假设$f(x)$一阶可导，那么$x^*$为局部最优解的&lt;strong&gt;必要条件&lt;/strong&gt;是一阶导数$f’(x^*)=0$。如果$f(x)$二阶可导，那么我们可以有&lt;strong&gt;充分条件&lt;/strong&gt;$f’(x^*)=0,f’’(x^*)&amp;gt;0$。对于凸问题，$f’’(x)\geq 0$恒成立，则$f’(x^*)=0$是$x^*$为(全局)最优解的&lt;strong&gt;充要条件&lt;/strong&gt;。但对于一般的非凸问题，并没有比较好用的充要条件。&lt;/p&gt;
&lt;p&gt;上述结论当然可以推广到高维的情况。考虑高维无约束优化问题$\min_x f(x)$，我们有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$x^*$为局部最优解的必要条件是$\nabla f(x)=0$&lt;/li&gt;
&lt;li&gt;$x^*$为局部最优解的充分条件是$\nabla f(x)=0$且$\nabla^2 f(x)$正定&lt;/li&gt;
&lt;li&gt;如果$f(x)$为凸函数，则$x^*$为全局最优解的充要条件为$\nabla f(x)=0$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述结论在一般的微积分课本中都有介绍，下面我们考虑如何把这些结论推广到约束优化中。实际上，我们只需要考虑第1种情况，因为后面两种情况是类似的。&lt;/p&gt;
&lt;h1 id=&quot;二、拉格朗日函数&quot;&gt;&lt;a href=&quot;#二、拉格朗日函数&quot; class=&quot;headerlink&quot; title=&quot;二、拉格朗日函数&quot;&gt;&lt;/a&gt;二、拉格朗日函数&lt;/h1&gt;&lt;p&gt;考虑下述约束优化问题：&lt;br&gt;\[&lt;br&gt;\min_x f(x) \\&lt;br&gt;\text{s.t. } g(x)\leq 0, h(x)=0&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;为了将其转化为无约束优化问题，我们可以利用所谓的&lt;strong&gt;拉格朗日函数&lt;/strong&gt;：&lt;br&gt;\[&lt;br&gt;L(x,\lambda,\mu) = f(x) + \lambda^T g(x) + \mu^T h(x)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;其中$\lambda\geq 0$。固定$x$，容易发现：&lt;br&gt;\[&lt;br&gt;\max_{\lambda\geq 0, \mu} L(x, \lambda, \mu) = \left\{&lt;br&gt;\begin{split}&lt;br&gt;f(x), &amp;amp;\text{if } g(x)\leq 0, h(x)=0\\&lt;br&gt;+\infty, &amp;amp;\text{otherwise}&lt;br&gt;\end{split}&lt;br&gt;\right.&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;这是因为，如果$g(x)&amp;gt;0$，则可以选择很大的$\lambda$，使$L$趋于正无穷。而如果$h(x)\neq 0$，则可以根据$h(x)$的符号，将$\mu$置为相同符号的大数，使$L$趋于正无穷。&lt;/p&gt;
&lt;p&gt;由此可见，原来的约束优化问题可以等价表达为：&lt;br&gt;\[&lt;br&gt;\min_x \max_{\lambda\geq 0, \mu} L(x, \lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;此时不再含有对$x$的约束$g(x)\leq 0, h(x)=0$，因为这些约束不满足的时候，必有$\max_{\lambda\geq 0, \mu} L=+\infty$，从而不可能成为最小值。然而，转化后的这个问题是一个$\min \max$类型的问题，而且第二层的$\max$中仍然要考虑$\lambda\geq 0$的约束。下面，我们来处理这个问题。&lt;/p&gt;
&lt;h1 id=&quot;三、KKT条件&quot;&gt;&lt;a href=&quot;#三、KKT条件&quot; class=&quot;headerlink&quot; title=&quot;三、KKT条件&quot;&gt;&lt;/a&gt;三、KKT条件&lt;/h1&gt;&lt;p&gt;引入了拉格朗日函数后，我们把优化问题的最优解记为$(x^*,\lambda^*,\mu^*)$，即：&lt;br&gt;\[&lt;br&gt;L(x^*,\lambda^*,\mu^*) = \min_x \max_{\lambda\geq 0, \mu} L(x, \lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;h2 id=&quot;3-1-互补松弛&quot;&gt;&lt;a href=&quot;#3-1-互补松弛&quot; class=&quot;headerlink&quot; title=&quot;3.1 互补松弛&quot;&gt;&lt;/a&gt;3.1 互补松弛&lt;/h2&gt;&lt;p&gt;在最优解中，由于$h(x)=0$，因此$(\mu^*)^Th(x^*)=0$，这是显然的。此外，注意到$g(x)\leq 0, \lambda\geq 0$，那么$(\lambda^*)^Tg(x)$是否有其他约束呢？事实上我们有：&lt;br&gt;\[&lt;br&gt;(\lambda^*)^Tg(x) = 0&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;换句话说，$\lambda^*$和$g(x^*)$中至少有一个为0。也可以解释为，如果$g(x^*)&amp;lt;0$，则$\lambda^*=0$。这个结果可以从拉格朗日函数$L$的定义直接得出。这个条件通常称为互补松弛条件。&lt;/p&gt;
&lt;h2 id=&quot;3-2-导数条件&quot;&gt;&lt;a href=&quot;#3-2-导数条件&quot; class=&quot;headerlink&quot; title=&quot;3.2 导数条件&quot;&gt;&lt;/a&gt;3.2 导数条件&lt;/h2&gt;&lt;p&gt;为了获得和无约束优化类似的“一阶导数为0”的条件，我们需要一些&lt;strong&gt;正则化条件&lt;/strong&gt;，其中最常见的条件是&lt;strong&gt;强对偶定理&lt;/strong&gt;：&lt;br&gt;\[&lt;br&gt;L(x^*,\lambda^*,\mu^*) = \min_x \max_{\lambda\geq 0, \mu} L(x, \lambda, \mu) = \max_{\lambda\geq 0, \mu} \min_x L(x, \lambda, \mu)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;即原问题和对偶问题的最优解重合。此时我们可以考虑上面连等式的第1项和第3项，并在第3项的上层优化中固定$\lambda=\lambda^*,\mu=\mu^*$，这样就只需要考虑下层优化，即：&lt;br&gt;\[&lt;br&gt;L(x^*,\lambda^*,\mu^*) = \min_x L(x, \lambda^*, \mu^*)&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;这已经是一个无约束优化问题了，我们可以直接写出其最优性必要条件：&lt;br&gt;\[&lt;br&gt;\nabla_xL(x^*,\lambda^*,\mu^*) = 0&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;这就是一阶导数条件在约束优化中的推广，根据$L$的定义，我们可以将其展开为：&lt;br&gt;\[&lt;br&gt;\nabla f(x^*) + \left(\lambda^*\right)^T\nabla g(x^*) + \left(\mu^*\right)^T \nabla h(x^*) = 0 \\&lt;br&gt;\]&lt;/p&gt;
&lt;h2 id=&quot;3-3-KKT条件&quot;&gt;&lt;a href=&quot;#3-3-KKT条件&quot; class=&quot;headerlink&quot; title=&quot;3.3 KKT条件&quot;&gt;&lt;/a&gt;3.3 KKT条件&lt;/h2&gt;&lt;p&gt;综上所述，在一些正则化条件（如强对偶条件）下，约束优化的必要条件为：&lt;br&gt;\[&lt;br&gt;\nabla f(x^*) + \left(\lambda^*\right)^T\nabla g(x^*) + \left(\mu^*\right)^T \nabla h(x^*) = 0 \\&lt;br&gt;\lambda^* \geq 0 \\&lt;br&gt;g(x^*) \leq 0 \\&lt;br&gt;h(x^*) = 0 \\&lt;br&gt;\left(\lambda^*\right)^T g(x^*) = 0&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;该式把约束优化问题转化为一组等式和不等式，对于简单的问题可以直接求解，对于复杂的问题，则为基于导数的优化方法提供了支撑。&lt;/p&gt;
&lt;p&gt;同样地，KKT条件也有充分条件的版本，此时只需添加$\nabla^2_xL(x^*,\lambda^*,\mu^*)$正定的条件即可。对于凸优化来说，由于海森矩阵能保证半正定，所以上述必要条件成为充分条件。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在最优性判别中，基于导数的方法是一种相当有效的方法。对于无约束优化，可以直接利用一阶导数作为必要性判据，利用二阶导数作为充分性判据。这种方法可以推广到约束优化中，也就是著名的KKT条件。&lt;/p&gt;
    
    </summary>
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="导数" scheme="http://cxsmarkchan.github.com/tags/%E5%AF%BC%E6%95%B0/"/>
    
      <category term="约束" scheme="http://cxsmarkchan.github.com/tags/%E7%BA%A6%E6%9D%9F/"/>
    
      <category term="KKT条件" scheme="http://cxsmarkchan.github.com/tags/KKT%E6%9D%A1%E4%BB%B6/"/>
    
      <category term="极值" scheme="http://cxsmarkchan.github.com/tags/%E6%9E%81%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>凸性对于优化问题的意义</title>
    <link href="http://cxsmarkchan.github.com/2017/10/20/optimization-convex/"/>
    <id>http://cxsmarkchan.github.com/2017/10/20/optimization-convex/</id>
    <published>2017-10-21T02:57:12.000Z</published>
    <updated>2017-10-27T04:29:33.508Z</updated>
    
    <content type="html">&lt;p&gt;在优化问题中，凸优化问题很重要的一类子问题。一般来说，凸优化问题的求解无论在理论上，还是在算法上，都比非凸优化问题要成熟很多。可以证明，凸优化问题的局部最优即为全局最优，这使得凸优化问题的全局最优解的寻找更为简单。但凸性的意义不止于此。一个有意思的结论是：一般的非凸问题不仅全局最优难以求解，甚至局部最优的求解也非常困难！这篇文章会简要介绍相关的结论。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、凸性的基本定义&quot;&gt;&lt;a href=&quot;#一、凸性的基本定义&quot; class=&quot;headerlink&quot; title=&quot;一、凸性的基本定义&quot;&gt;&lt;/a&gt;一、凸性的基本定义&lt;/h1&gt;&lt;p&gt;优化问题的基本形式为：&lt;br&gt;\[&lt;br&gt;\min_x f(x) \\&lt;br&gt;\text{s.t. } g(x)\leq 0&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;以$f(x)$为例，我们可以按如下方式定义凸性：任取定义域中的两个点$x_1$和$x_2$，计算它们的函数值$f(x_1)$和$f(x_2)$，并计算它们的中点的函数值$f(\frac{x_1+x_2}{2})$，如果中点的函数值不大于两个端点的函数值的均值，即：&lt;br&gt;\[&lt;br&gt;f\left(\frac{x_1+x_2}{2}\right) \leq \frac{f(x_1)+f(x_2)}{2}&lt;br&gt;\]&lt;br&gt;我们就称$f(x)$为凸函数。凸函数的图像是一个向下凸出的图像。&lt;/p&gt;
&lt;p&gt;如果$f(x)$和$g(x)$都是凸函数，那么这个优化问题就称为凸优化问题。&lt;/p&gt;
&lt;p&gt;当然，对于$g(x)$，我们还有另一种更一般化的定义方式。观察$g(x)\leq 0$的图像，可以发现，如果任意两个点$x_1$和$x_2$在这个集合内，那么它们的中点同样在这个集合内部。满足这种性质的集合，我们称为凸集。事实上，凸优化问题可以定义为：约束为凸集，目标函数为凸函数的最小化问题。这个定义比前面的定义会更加广泛一些，因为有的时候，约束并不能写成$g(x)\leq 0$的形式。&lt;/p&gt;
&lt;h1 id=&quot;二、凸优化问题的性质&quot;&gt;&lt;a href=&quot;#二、凸优化问题的性质&quot; class=&quot;headerlink&quot; title=&quot;二、凸优化问题的性质&quot;&gt;&lt;/a&gt;二、凸优化问题的性质&lt;/h1&gt;&lt;h2 id=&quot;2-1-局部最优和全局最优&quot;&gt;&lt;a href=&quot;#2-1-局部最优和全局最优&quot; class=&quot;headerlink&quot; title=&quot;2.1 局部最优和全局最优&quot;&gt;&lt;/a&gt;2.1 局部最优和全局最优&lt;/h2&gt;&lt;p&gt;这里首先需要说明局部最优和全局最优的概念。&lt;/p&gt;
&lt;p&gt;全局最优的概念很简单，如果有一个$x_0$满足约束，并且在约束成立的范围内，没有其他$x$，使$f(x)&amp;lt;f(x_0)$，就把$x_0$称为全局最优。简单来说，全局最优就是在约束满足的范围内的最小值。&lt;br&gt;局部最优的要求松一些，如果有一个$x_0$满足约束，并且在$x_0$附近（严格的说是&lt;strong&gt;邻域&lt;/strong&gt;），没有其他满足约束的$x$，使$f(x)&amp;lt;f(x_0)$，就把$x_0$称为局部最优。简单来说，局部最优只需要保证在该点附近（可能范围很小）保证最优即可。&lt;/p&gt;
&lt;p&gt;由此可见，为了确保局部最优，只需要在一个点的附近检查即可。如果目标函数满足一些可微性条件，这个“局部”甚至可以用该点的微分性质来判定。很容易想象，全局最优的判断要复杂很多，因为需要检查所有可能的解。但这里我想说的是，无论是局部最优还是全局最优，判定都不是一件简单的事情。当然，我所指的判定是&lt;strong&gt;充要条件&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-2-局部最优和全局最优的关系&quot;&gt;&lt;a href=&quot;#2-2-局部最优和全局最优的关系&quot; class=&quot;headerlink&quot; title=&quot;2.2 局部最优和全局最优的关系&quot;&gt;&lt;/a&gt;2.2 局部最优和全局最优的关系&lt;/h2&gt;&lt;p&gt;对于全局最优的求解，并没有一个一般的方法，因为所有的分析学工具都是针对“局部”，或者说，微分性质的。一种比较直观的思路是：是否有一种优化问题，其局部最优就是全局最优？这个问题的答案是肯定的，凸优化就是其中的一种。&lt;/p&gt;
&lt;p&gt;我们这里不做严格证明，但可以简单论述一下。如果凸优化的局部最优不是全局最优，我们可以把该局部最优和全局最优连线。首先，由于约束是凸集，这条线必然在可行集内部。然后，从这个局部最优点看过去，这条线应该是“往下”的，因为全局最优解在它的“下方”（或者说，斜下方）。这就出现了矛盾：在局部最优的附近，所有的函数点都在它的“上方”，如果有函数值在下方，这个点也就不是局部最优解了！因此，凸优化的局部最优解也就是全局最优解。&lt;/p&gt;
&lt;h1 id=&quot;三、非凸问题的NP性质&quot;&gt;&lt;a href=&quot;#三、非凸问题的NP性质&quot; class=&quot;headerlink&quot; title=&quot;三、非凸问题的NP性质&quot;&gt;&lt;/a&gt;三、非凸问题的NP性质&lt;/h1&gt;&lt;p&gt;我们已经知道，凸优化问题在某种程度上是“简单”的。一个很自然的问题是，非凸优化问题是不是真的“难”？或者说，是不是还有别的方式来找到非凸优化问题的局部最优解和全局最优解？当然，有可能有部分非凸优化问题可以在比较短的时间内求解，但我们关心的是一般的非凸问题。&lt;br&gt;当然，所谓“简单”和“难”都是相对的，我们这里可以说明，部分非凸问题的全局最优解、局部最优解的求解都是所谓的&lt;strong&gt;NP完全问题&lt;/strong&gt;。至少到目前为止，NP完全问题在求解上还存在着极大的困难，因此，在NP完全问题被攻克前，我们不能奢求对于&lt;strong&gt;一般&lt;/strong&gt;的非凸问题求解全局最优解，甚至求解局部最优解也是不可行的。&lt;/p&gt;
&lt;h2 id=&quot;3-1-非凸问题的全局最优解&quot;&gt;&lt;a href=&quot;#3-1-非凸问题的全局最优解&quot; class=&quot;headerlink&quot; title=&quot;3.1 非凸问题的全局最优解&quot;&gt;&lt;/a&gt;3.1 非凸问题的全局最优解&lt;/h2&gt;&lt;p&gt;为了论述全局最优解的NP完全性，我们需要找一个已知的NP完全问题，并证明全局最优解的求解难度和这个已知问题相同。我们寻找的NP完全问题是&lt;strong&gt;部分和问题&lt;/strong&gt;：给定一个数组和一个数字，该数组是否存在子数组，其和等于该数字？用数学语言叙述则为：给定数字$d_0$和一个数组$d_1,d_2,\dots,d_n$，问：是否存在$y_j\in{0,1},j=1,2,\dots,n$使得：&lt;br&gt;\[&lt;br&gt;\sum_{j=1}^nd_jy_j=d_0&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;我们把上述问题称为&lt;strong&gt;问题1&lt;/strong&gt;。同时，我们考虑如下问题(&lt;strong&gt;问题2&lt;/strong&gt;)：&lt;br&gt;\[&lt;br&gt;\min \left(\sum_{j=1}^nd_jy_j-d_0\right)^2+\sum_{j=1}^ny_j(1-y_j) \\&lt;br&gt;\text{s.t. } 0 \leq y_j \leq 1, j=1,2,\dots, n&lt;br&gt;\]&lt;br&gt;注意，在第一个问题中，我们假设了$y_j$是整数，而第二个问题中，我们并没有假设$y_j$是整数。不难看出，问题2的目标函数始终是不小于0的。当问题1有解的时候，把该解代入问题2，就可以得到目标函数的最小值0。反过来，当问题2的目标函数最小值为0时，$y_j$只能都取0或1（否则第二项大于0，第一项不小于0，目标函数不可能等于0），这个解也满足问题1。&lt;/p&gt;
&lt;p&gt;因此我们得出结论，问题1有解和问题2全局最优解为0是等价的。由于问题1是NP完全问题，问题2的全局最优解的求解也只能是NP完全问题。&lt;/p&gt;
&lt;p&gt;这里要注意，我们并没有求解问题2的全局最优解，而是验证全局最优解是否为0。如果这种验证都被证明是一件“困难”的事，那么全局最优解的求解只会更加困难。&lt;/p&gt;
&lt;h2 id=&quot;3-2-含约束非凸问题的局部最优解&quot;&gt;&lt;a href=&quot;#3-2-含约束非凸问题的局部最优解&quot; class=&quot;headerlink&quot; title=&quot;3.2 含约束非凸问题的局部最优解&quot;&gt;&lt;/a&gt;3.2 含约束非凸问题的局部最优解&lt;/h2&gt;&lt;p&gt;这里我们考虑如下问题（&lt;strong&gt;问题3&lt;/strong&gt;）：&lt;br&gt;\[&lt;br&gt;\min Q(x) = x^TDx, x\geq 0&lt;br&gt;\]&lt;br&gt;其中$D$是$n$阶矩阵，其元素均为整数。&lt;/p&gt;
&lt;p&gt;Murty证明了如下定理：验证0是否为问题3的局部最优解，是一个NP完全问题！这个定理非常有意思，我们将在另一篇博客中论述。但同样的，如果局部最优解的判定已经是NP完全问题，那么局部最优解的求解只可能更加困难。&lt;/p&gt;
&lt;h2 id=&quot;3-3-无约束非凸问题的局部最优解&quot;&gt;&lt;a href=&quot;#3-3-无约束非凸问题的局部最优解&quot; class=&quot;headerlink&quot; title=&quot;3.3 无约束非凸问题的局部最优解&quot;&gt;&lt;/a&gt;3.3 无约束非凸问题的局部最优解&lt;/h2&gt;&lt;p&gt;3.2的条件中含有约束$x\geq 0$，也就是说，对于一般的含约束的非凸问题，没有有效的方法验证局部最优解。实际上，只要稍作修改，就可以发现，一般的无约束非凸问题也没有有效的方法验证局部最优解。我们只需要令$x=u^2$，则问题3转化为：&lt;br&gt;\[&lt;br&gt;\min Q(x) = [u^2]^TD[u^2]&lt;br&gt;\]&lt;br&gt;此时，对于u就是无约束优化问题了。显然，这个问题和问题3是等价的，它也是NP完全问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在优化问题中，凸优化问题很重要的一类子问题。一般来说，凸优化问题的求解无论在理论上，还是在算法上，都比非凸优化问题要成熟很多。可以证明，凸优化问题的局部最优即为全局最优，这使得凸优化问题的全局最优解的寻找更为简单。但凸性的意义不止于此。一个有意思的结论是：一般的非凸问题不仅全局最优难以求解，甚至局部最优的求解也非常困难！这篇文章会简要介绍相关的结论。&lt;br&gt;
    
    </summary>
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="凸优化" scheme="http://cxsmarkchan.github.com/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>优化模型（一）：优化的要素</title>
    <link href="http://cxsmarkchan.github.com/2017/10/12/optimization-config/"/>
    <id>http://cxsmarkchan.github.com/2017/10/12/optimization-config/</id>
    <published>2017-10-12T04:39:11.000Z</published>
    <updated>2017-10-12T04:42:35.754Z</updated>
    
    <content type="html">&lt;p&gt;在工程学科中，大量的问题均可以转化为优化问题。从字面意义上，优化即为在允许的范围(约束)内调整决策变量，使某个目标达到最大或最小。然而，在数学上处理优化之前，很自然的问题是：优化问题应该如何用数学语言表达？它有那些要素需要注意？这篇博客简要介绍优化问题的决策变量、目标函数和约束，这也是优化问题最基础的知识。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、最简单的优化问题&quot;&gt;&lt;a href=&quot;#一、最简单的优化问题&quot; class=&quot;headerlink&quot; title=&quot;一、最简单的优化问题&quot;&gt;&lt;/a&gt;一、最简单的优化问题&lt;/h1&gt;&lt;p&gt;最简单的优化问题在中学课本中就已经出现，例如初中学二次函数时，必然会讨论其极值问题，这是最简单的无约束优化问题。而下面的例子来源于高中课本，可以算最简单的约束优化问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（摘自人教版高中数学必修5）某工厂用A、B两种配件生产甲乙两种产品，每生产一件甲产品使用4个A配件，耗时1h；每生产一件乙产品使用4个B配件，耗时2h。该厂每天最多可从配件厂获得16个A配件和12个B配件，每天工作8h。生产一件甲产品获利2万元，生产一件乙产品获利3万元，应该如何安排生产，使得总收益最大？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题虽然简单，但已经具备了一个优化问题的必备条件。首先是&lt;strong&gt;决策变量&lt;/strong&gt;，也就是我们可以调整的变量，此处为“每天生产甲乙两种产品的数量”。然后是&lt;strong&gt;目标函数&lt;/strong&gt;，即我们希望最小化（或最大化）的目标，此处为“每天生产的净收益”。最后，如果因为现实因素，我们的决策变量不能任意选取，那么还需要考虑&lt;strong&gt;约束条件&lt;/strong&gt;，此处为“每天的A、B两种配料的供给和工作时长限制”。&lt;/p&gt;
&lt;p&gt;如果我们设每天生产甲产品$x_1$件，生产乙产品$x_2$件，那么很容易列出下面的方程：&lt;br&gt;\begin{align*}&lt;br&gt;\max_{x_1,x_2} 2x_1&amp;amp;+3x_2 \\&lt;br&gt;4x_1&amp;amp;\leq 16 （约束：A配件）\\&lt;br&gt;4x_2&amp;amp;\leq 12 （约束：B配件）\\&lt;br&gt;x_1+2x_2&amp;amp;\leq 8 （约束：工作时间）&lt;br&gt;\end{align*}&lt;/p&gt;
&lt;h1 id=&quot;二、优化问题的一般形式&quot;&gt;&lt;a href=&quot;#二、优化问题的一般形式&quot; class=&quot;headerlink&quot; title=&quot;二、优化问题的一般形式&quot;&gt;&lt;/a&gt;二、优化问题的一般形式&lt;/h1&gt;&lt;p&gt;由此可见，确定了决策变量、目标函数、约束这三个要素之后，即可将优化问题转化为数学形式，而列出数学形式是求解优化问题的前提条件。我们可以将上面的例子作一般化的推广，把优化问题描述为如下形式：&lt;br&gt;\begin{equation*}&lt;br&gt;\min_x f(x) \\&lt;br&gt;\text{s.t. }x\in \mathcal{X}&lt;br&gt;\end{equation*}&lt;/p&gt;
&lt;p&gt;其中$x$为决策变量，$f(x)$为目标函数；而$\mathcal{X}$则是约束。所谓优化问题的建模，不过是回答如下问题：决策变量$x$有哪些？目标函数$f(x)$如何描述？约束$\mathcal{X}$是什么形式？解决了这几个问题，我们就可以把优化问题描述成标准的数学形式。&lt;/p&gt;
&lt;p&gt;在这三个要素中，决策变量和目标函数是必须存在的，约束则不一定（或许不应该称作“要素”）。也有很多优化问题，其决策变量并不受约束，或者约束很宽松，可以忽略，我们称作“无优化约束”，它们的求解是解决含优化约束问题的基础。&lt;/p&gt;
&lt;p&gt;当然，上面的例子只是实际问题的一个特例，甚至算特例中的特例。为什么这么说？首先，这是一个&lt;strong&gt;确定性规划&lt;/strong&gt;，我们生产$x_1$件甲产品，$x_2$件乙产品，那么获得的利润一定是$2x_1+3x_2$，同时，每天都是严格的8小时工作制，配件厂每天提供的配件也是固定的。那么有没有可能每天的客户需求是有变化的？工厂的设备和工人的工作效率都是恒定的吗？配件厂每天都有足量的配件吗？诚然，在实际生产中，我们有诸多措施（例如合同等）来保障意外情况不会发生，但在有的生产环境中，这些不确定性是有必要考虑的。&lt;/p&gt;
&lt;p&gt;不仅如此，这个问题还是一个&lt;strong&gt;线性规划&lt;/strong&gt;——目标函数和约束都是线性的。同样，我们可以提出一些问题：生产产品的总利润是正比于产品数量的吗？有没有规模效应？生产产品数量多的时候，速度会不会加快？诸如此类，都会让问题变得更加复杂。&lt;/p&gt;
&lt;p&gt;如何选取模型是一个很复杂的问题，难以用统一的标准来衡量。简单来说，越精细的模型，通常计算难度越大，甚至有的模型目前为止还没有很好的求解方法。因此，选取模型的时候需要在准确性和求解难度之间进行权衡。&lt;/p&gt;
&lt;h1 id=&quot;三、小结&quot;&gt;&lt;a href=&quot;#三、小结&quot; class=&quot;headerlink&quot; title=&quot;三、小结&quot;&gt;&lt;/a&gt;三、小结&lt;/h1&gt;&lt;p&gt;决策变量、目标函数、约束，这些内容对于做优化的人来说，是很基础的内容，每个人都耳熟能详。在优化的教科书中，这几个术语也不过是几行定义。但在科研和交流的过程中，我曾见到过一些甚至研究生高年级的同学，在这个方面仍然会犯常识性错误。参加我们学科（电力系统）最大的学术年会，也看到一些做系统优化的人对研究成果中的明显错误毫无概念——以为自己做了随机优化，实际上是确定性优化；以为自己的结果是解复杂优化算出来的，实际上问题只有平凡解，诸如此类。&lt;/p&gt;
&lt;p&gt;每个人都知道怎么用商业软件求解优化问题，但商业软件并不能告诉我们优化目标是否合理，约束形式是否正确，以及一个变量该不该作为决策变量。我曾经看到过一类很热门的研究，采用的优化模型和实际并不相符。当然，采用简化的模型无可厚非。但令人吃惊的是，绝大多数用这个模型做研究的人，丝毫没有意识到这是一个有很大程度简化的模型——他们只是很放心大胆地在使用。&lt;/p&gt;
&lt;p&gt;对于做工程学科的人来说，掌握数学工具当然是好的，但在使用数学工具之前，总得明白自己的问题是什么。所以，我们在做优化之前，还是要牢记这样几个问题：&lt;strong&gt;决策变量是什么？目标是什么？约束是什么？&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在工程学科中，大量的问题均可以转化为优化问题。从字面意义上，优化即为在允许的范围(约束)内调整决策变量，使某个目标达到最大或最小。然而，在数学上处理优化之前，很自然的问题是：优化问题应该如何用数学语言表达？它有那些要素需要注意？这篇博客简要介绍优化问题的决策变量、目标函数和约束，这也是优化问题最基础的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="模型" scheme="http://cxsmarkchan.github.com/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>双线性约束的精确松弛</title>
    <link href="http://cxsmarkchan.github.com/2016/05/12/bilinear/"/>
    <id>http://cxsmarkchan.github.com/2016/05/12/bilinear/</id>
    <published>2016-05-13T00:40:32.000Z</published>
    <updated>2017-09-26T00:15:12.454Z</updated>
    
    <content type="html">&lt;p&gt;今天想谈一个研究中常见的问题，即含有双线性约束的优化问题。&lt;br&gt;双线性约束即形为$z=xy$的约束，这是一类在电力领域中很常见的约束。对于含有一般双线性约束的优化问题，目前还没有很好的求解方法，不过，有一些特殊的双线性约束是可以被等价转化成线性约束的，本文即讨论这些约束形式以及相应的转化技巧。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容: cxsmarkchan&lt;/p&gt;
&lt;h1 id=&quot;1-双线性约束举例&quot;&gt;&lt;a href=&quot;#1-双线性约束举例&quot; class=&quot;headerlink&quot; title=&quot;1 双线性约束举例&quot;&gt;&lt;/a&gt;1 双线性约束举例&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;之所以说双线性约束$z=xy$难以求解，是因为它不仅是非线性的，而且是非凸的。&lt;/strong&gt;关于凸性可以参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Convex_set&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wikipedia&lt;/a&gt;的解释。对于这个问题，简单来说，是指如果三维空间中的两个点$x_1,y_1,z_1$和$x_2,y_2,z_2$都满足约束，即$z_1=x_1y_1,z_2=x_2y_2$，那么这两点所连接的线段上的点$\left(x,y,z\right)$是否也满足$\left(z=xy\right)$。很明显，双线性约束不满足这个条件。例如，$(1,2,2)$和$(2,4,8)$都满足$z=xy$的条件，但是它们的中点$(1.5,3,5)$显然不满足条件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前，我们的数学工具能在很大程度上求解凸优化问题，但对于非凸优化问题，目前还没有很成熟的求解方法。&lt;/strong&gt;这也是含双线性约束的优化问题让人头疼的原因。不巧的是，在电力领域的研究中，很难回避双线性问题。举几个简单的例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;功率约束$P=UI$本身就是双线性的，这意味着所有的交流潮流问题都是双线性问题。&lt;/li&gt;
&lt;li&gt;电网中，上网电价和用电电价是不相等的。在这种情况下，储能系统充电和放电的情况要分开考虑。储能从电网充电的成本是$\lambda^+ P^+$，其中$\lambda^+$是用电电价，$P^+$是充电功率。而储能向电网放电的收益是$\lambda^- P^-$，其中$\lambda^-$是上网电价，$P^-$是放电功率。很明显，同一个时刻，储能要么充电、要么放电，因此必然有$P^+P^-=0$，这也是个双线性问题。&lt;/li&gt;
&lt;li&gt;电力市场中的博弈行为常常涉及多层优化问题，动态博弈的均衡点求解需要用到互补松弛条件，这也是一个双线性的条件。&lt;/li&gt;
&lt;li&gt;在电网规划或者状态估计中，会遇到一些含逆运算的约束问题（例如导纳和阻抗的关系），即$z=y^{-1}$的问题。这里的$y$会受到一个操作的影响，即$y=y_0+b\Delta y$，其中b是0-1变量，表示我们是否执行了该操作。未执行操作时，$y=y_0$；执行操作时，$y=y_0+\Delta y$。这样，约束就变成了$z=(y_0+b\Delta y)^{-1}$，即$y_0z+bz\Delta y=1$。其中的$bz$就是双线性项。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，第一个问题可以说是电力系统稳态分析的一个痛点。对于辐射网，目前已经有了一些比较好的解决方法，可以参考Steven Low关于最优潮流的研究成果。但对于一般的网络，只能考虑求取次优解。这篇博客不打算讨论该问题，但以后有时间的话，我会争取把我了解到的相关研究整理出来。&lt;/p&gt;
&lt;p&gt;问题2到问题4都可以通过一定的技巧转化成（含整数的）线性问题，这也是后文讨论的重点。&lt;/p&gt;
&lt;h1 id=&quot;2-双线性约束的标准形式&quot;&gt;&lt;a href=&quot;#2-双线性约束的标准形式&quot; class=&quot;headerlink&quot; title=&quot;2 双线性约束的标准形式&quot;&gt;&lt;/a&gt;2 双线性约束的标准形式&lt;/h1&gt;&lt;p&gt;双线性在优化问题中可以有多种形式，以下面的优化问题为例：&lt;/p&gt;
&lt;p&gt;\[&lt;br&gt;\begin{aligned}&lt;br&gt;\text{min } &amp;amp; x_1 + x_2x_3 \\&lt;br&gt;\text{s.t. } &amp;amp; x_2 \leq x_4x_5 \\&lt;br&gt;&amp;amp; x_3 = x_6\left(x_7 + 2\right)&lt;br&gt;\end{aligned}&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;这个方程里面含有三个双线性部分，第一个在目标函数中，第二个在不等式约束中，第三个则在等式约束中。粗略看来，在不同位置的非线性量通常要用不同的方法来处理，但事实上，我们可以通过一定的变换，把这些双线性部分用标准形式来表达。&lt;/p&gt;
&lt;p&gt;所谓标准形式，是指形如$z=xy$的约束。例如上述优化问题，我们也可以用如下形式表达：&lt;/p&gt;
&lt;p&gt;\[&lt;br&gt;\begin{aligned}&lt;br&gt;\text{min } &amp;amp; x_1 + z_1 \\&lt;br&gt;\text{s.t. } &amp;amp; x_2 \leq z_2 \\&lt;br&gt;&amp;amp; x_3 = x_6z_3 \\&lt;br&gt;&amp;amp; z_1 = x_2x_3 \\&lt;br&gt;&amp;amp; z_2 = x_4x_5 \\&lt;br&gt;&amp;amp; z_3 = x_7 + 2 \\&lt;br&gt;\end{aligned}&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;很容易看出，转化后的形式和转化前的形式相比，实际上只是做了几个变量替换，但目标函数中已经不存在双线性量，而且所有的双线性量都出现在了等式约束中。通过这样的转化，我们就可以把主要精力集中在对标准双线性形式的处理上。&lt;/p&gt;
&lt;h1 id=&quot;3-双线性约束的精确松弛&quot;&gt;&lt;a href=&quot;#3-双线性约束的精确松弛&quot; class=&quot;headerlink&quot; title=&quot;3 双线性约束的精确松弛&quot;&gt;&lt;/a&gt;3 双线性约束的精确松弛&lt;/h1&gt;&lt;h2 id=&quot;3-1-利用目标函数实现精确松弛&quot;&gt;&lt;a href=&quot;#3-1-利用目标函数实现精确松弛&quot; class=&quot;headerlink&quot; title=&quot;3.1 利用目标函数实现精确松弛&quot;&gt;&lt;/a&gt;3.1 利用目标函数实现精确松弛&lt;/h2&gt;&lt;p&gt;对于第1节提到的问题2，其约束为$P^+P^-=0$。这个约束并不是单独出现的，而是一般会出现在和储能有关的优化问题中。这类优化问题的一般形式如下：&lt;/p&gt;
&lt;p&gt;\[&lt;br&gt;\begin{aligned}&lt;br&gt;\text{min } &amp;amp; \lambda^+P^+ - \lambda^-P^- \\&lt;br&gt;\text{s.t.} &amp;amp; P^+ \geq 0,P^- \geq 0 \\&lt;br&gt;&amp;amp; P^+P^-=0 \\&lt;br&gt;&amp;amp; f\left(P^+ - P^-\right) \leq 0&lt;br&gt;\end{aligned}&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;其中，最后一个条件表示，对于外界来说，只有储能实际的出力，即$P^+ - P^-$是受到关心的。也就是说，在不考虑前两个约束时，$P^+$和$P^-$同时增加或降低一个数，对外界来说是没有影响的。&lt;/p&gt;
&lt;p&gt;同时，一般来说，上网电价会低于用电电价，即$\lambda^+ &amp;gt; \lambda^- $。其直观的意义是：储能在某个时刻，充一定量的电，再把这些点送回电网，那么电网会收取过网费，因此储能会亏损。&lt;/p&gt;
&lt;p&gt;在这两个条件下，我们会发现，双线性的互补松弛约束完全可以删去。这是因为，储能把最小化成本作为目标函数，那么它一定不会选择在同一时刻“既充电又放电”的决策，因为这个决策是亏损的。既然优化问题的目标函数使得这种决策不会被选择，我们就没必要在约束条件中禁止这种决策的出现——即使出现了，也不会成为最优策略！&lt;/p&gt;
&lt;p&gt;因此，利用目标函数的特性，我们把问题改写成了如下格式：&lt;/p&gt;
&lt;p&gt;\[&lt;br&gt;\begin{aligned}&lt;br&gt;\text{min } &amp;amp; \lambda^+P^+ - \lambda^-P^- \\&lt;br&gt;\text{s.t.} &amp;amp; P^+ \geq 0,P^- \geq 0 \\&lt;br&gt;&amp;amp; f\left(P^+ - P^-\right) \leq 0&lt;br&gt;\end{aligned}&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;这个方法的关键在于：我们一般会在约束条件中禁止一些不合要求的策略（例如储能既充电又放电是不符合实际的），但如果这个策略本身不可能是最优策略，那么我们也就没必要在约束条件中禁止它了。&lt;/p&gt;
&lt;h2 id=&quot;3-2-利用大数实现精确松弛&quot;&gt;&lt;a href=&quot;#3-2-利用大数实现精确松弛&quot; class=&quot;headerlink&quot; title=&quot;3.2 利用大数实现精确松弛&quot;&gt;&lt;/a&gt;3.2 利用大数实现精确松弛&lt;/h2&gt;&lt;p&gt;3.1节的方法只适合于目标函数“比较配合”的情形，对于一般的互补松弛约束（如问题3）是不适用的。这种情况下，我们还可以采用大数的方法松弛。&lt;/p&gt;
&lt;p&gt;例如一个$xy=0,x \geq 0, y \geq 0$的约束，我们可以引入两个0-1整数变量$b_1,b_2$和一个很大的数$M$，并把约束改写成如下形式：&lt;br&gt;\[&lt;br&gt;0 \leq x \leq b_1M \\&lt;br&gt;0 \leq y \leq b_2M \\&lt;br&gt;b_1 + b_2 \leq 1&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;以上形式是含整数的线性约束。注意到$b_1,b_2$是0-1变量，因此第3个约束保证了$b_1$和$b_2$最多只有1个是1，或者说，至少有1个是0。&lt;/p&gt;
&lt;p&gt;那么$b_1$和$b_2$的值有什么意义呢？我们以$b_1$为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$b_1=0$，第1个约束变成了$0 \leq x \leq 0$，也就是$x=0$&lt;/li&gt;
&lt;li&gt;如果$b_1=1$，第1个约束变成了$0 \leq x \leq M$，由于$M$是一个很大的数，超过了$x$可能的取值返回，我们可以认为$M$对$x$不产生约束。因此，该约束就变成了$x \geq 0$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可见，$b_1$和$b_2$最少有1个是0，也就意味着$x$和$y$最少有1个是0，因此互补松弛约束也就满足了。这样，互补松弛约束就被等价变换成了含整数的线性约束。&lt;/p&gt;
&lt;p&gt;大数和整数变量还可以用于问题4的精确松弛。问题4中的关键部分在于$bz$，我们可以写成$w=bz$的形式，其中$w$和$z$是连续变量，$b$是0-1变量。$w=bz$可以被改写成如下形式：&lt;/p&gt;
&lt;p&gt;\[&lt;br&gt;\left| w \right| \leq bM \\&lt;br&gt;\left| w - z \right| \leq (1-b)M \\&lt;br&gt;\]&lt;/p&gt;
&lt;p&gt;注意到$b=0$时，第1个约束收紧为$w=0$，第2个约束因为$M$很大而不起作用；$b=1$时，第1个约束不起作用，第2个约束收紧为$w-z=0$。因此，这两个式子和$w=bz$是等价的：在$b=0$时，$w=0$；在$b=1$时，$w=z$。&lt;/p&gt;
&lt;p&gt;相关参考文献：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关于问题1中非线性约束在辐射网中的求解，可参考：M. Farivar and S. H. Low, “Branch Flow Model: Relaxations and Convexification—Part I,” in IEEE Transactions on Power Systems, vol. 28, no. 3, pp. 2554-2564, Aug. 2013.&lt;/li&gt;
&lt;li&gt;关于问题3中互补松弛约束的求解，可参考：C. Ruiz and A. J. Conejo, “Pool Strategy of a Producer With Endogenous Formation of Locational Marginal Prices,” in IEEE Transactions on Power Systems, vol. 24, no. 4, pp. 1855-1866, Nov. 2009.&lt;/li&gt;
&lt;li&gt;关于问题4中求逆问题的求解，可参考：X. Chen; J. Lin; C. Wan; Y. Song; S. You; Y. Zong; W. Guo; Y. Li, “Optimal Meter Placement for Distribution Network State Estimation: A Circuit Representation Based MILP Approach,” in IEEE Transactions on Power Systems (Early Access)&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天想谈一个研究中常见的问题，即含有双线性约束的优化问题。&lt;br&gt;双线性约束即形为$z=xy$的约束，这是一类在电力领域中很常见的约束。对于含有一般双线性约束的优化问题，目前还没有很好的求解方法，不过，有一些特殊的双线性约束是可以被等价转化成线性约束的，本文即讨论这些约束形式以及相应的转化技巧。&lt;br&gt;
    
    </summary>
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="双线性" scheme="http://cxsmarkchan.github.com/tags/%E5%8F%8C%E7%BA%BF%E6%80%A7/"/>
    
      <category term="优化" scheme="http://cxsmarkchan.github.com/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="松弛" scheme="http://cxsmarkchan.github.com/tags/%E6%9D%BE%E5%BC%9B/"/>
    
  </entry>
  
  <entry>
    <title>linux源码分析：schedule进程调度</title>
    <link href="http://cxsmarkchan.github.com/2016/04/18/linux-schedule/"/>
    <id>http://cxsmarkchan.github.com/2016/04/18/linux-schedule/</id>
    <published>2016-04-18T04:44:59.000Z</published>
    <updated>2017-09-25T22:52:56.978Z</updated>
    
    <content type="html">&lt;p&gt;schedule是linux中的一个内核函数，用于实现进程调度。该函数由内核线程在合适的时机调用，完成进程上下文的切换。本文从源码的角度分析了schedule函数的执行过程，尤其是进程上下文的切换过程。本文所分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;原创内容：cxsmarkchan 陈晓爽&lt;br&gt;转载请注明出处&lt;br&gt;&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:ustcX+USTC001+_/about&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;linux内核分析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-进程调度的基本方法&quot;&gt;&lt;a href=&quot;#1-进程调度的基本方法&quot; class=&quot;headerlink&quot; title=&quot;1 进程调度的基本方法&quot;&gt;&lt;/a&gt;1 进程调度的基本方法&lt;/h1&gt;&lt;p&gt;进程调度是操作系统的核心部分，操作系统的大多数行为，都可以概括为“从一个进程切换到另一个进程”。进程调度的时候，通常需要如下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择下一个要调度的进程&lt;/li&gt;
&lt;li&gt;保存当前进程的上下文&lt;/li&gt;
&lt;li&gt;切换到下一个进程的上下文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;linux系统在很多位置都会调用schedule函数，典型的调用场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统进行常规的进程调度&lt;/li&gt;
&lt;li&gt;在系统调用或其他中断的时候，会允许进行进程调度&lt;/li&gt;
&lt;li&gt;内核线程主动进行进程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-schedule函数的执行过程&quot;&gt;&lt;a href=&quot;#2-schedule函数的执行过程&quot; class=&quot;headerlink&quot; title=&quot;2 schedule函数的执行过程&quot;&gt;&lt;/a&gt;2 schedule函数的执行过程&lt;/h1&gt;&lt;h2 id=&quot;2-1-schedule函数&quot;&gt;&lt;a href=&quot;#2-1-schedule函数&quot; class=&quot;headerlink&quot; title=&quot;2.1 schedule函数&quot;&gt;&lt;/a&gt;2.1 schedule函数&lt;/h2&gt;&lt;p&gt;schedule函数定义在&lt;code&gt;kernel/sched/core.c&lt;/code&gt;中，其定义如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;asmlinkage __visible &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __&lt;span class=&quot;function&quot;&gt;sched &lt;span class=&quot;title&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *tsk = current;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sched_submit_work(tsk);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	__schedule();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见其最主要的内容是调用了&lt;code&gt;__schedule&lt;/code&gt;函数。&lt;/p&gt;
&lt;h2 id=&quot;2-2-schedule函数&quot;&gt;&lt;a href=&quot;#2-2-schedule函数&quot; class=&quot;headerlink&quot; title=&quot;2.2 __schedule函数&quot;&gt;&lt;/a&gt;2.2 __schedule函数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;__schedule&lt;/code&gt;函数执行了所有的进程调度工作。其主要功能为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取当前进程和下一个进程的进程控制块&lt;/li&gt;
&lt;li&gt;判断当前进程和下一个进程是否相同，如果不同，则调用&lt;code&gt;switch_context&lt;/code&gt;函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;__schedule&lt;/code&gt;函数的重要代码如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __sched __schedule(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *prev, *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; *switch_count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; rq *rq;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cpu;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;need_resched:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    preempt_disable();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cpu = smp_processor_id();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rq = cpu_rq(cpu);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	prev = rq-&amp;gt;curr; &lt;span class=&quot;comment&quot;&gt;//获取了当前进程的进程控制块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	next = pick_next_task(rq, prev); &lt;span class=&quot;comment&quot;&gt;//获取了下一个进程的进程控制块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	clear_tsk_need_resched(prev);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	clear_preempt_need_resched();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rq-&amp;gt;skip_clock_update = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (likely(prev != next)) &amp;#123; &lt;span class=&quot;comment&quot;&gt;//判断当前进程和下一个进程是否相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		rq-&amp;gt;nr_switches++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		rq-&amp;gt;curr = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		++*switch_count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		context_switch(rq, prev, next); &lt;span class=&quot;comment&quot;&gt;//切换进程上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		cpu = smp_processor_id();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		rq = cpu_rq(cpu);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		raw_spin_unlock_irq(&amp;amp;rq-&amp;gt;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	post_schedule(rq);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sched_preempt_enable_no_resched();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-3-pick-next-task函数&quot;&gt;&lt;a href=&quot;#2-3-pick-next-task函数&quot; class=&quot;headerlink&quot; title=&quot;2.3 pick_next_task函数&quot;&gt;&lt;/a&gt;2.3 pick_next_task函数&lt;/h2&gt;&lt;p&gt;pick_next_task函数位于&lt;code&gt;kernel/sched/core.c&lt;/code&gt;，其功能为获取下一个进程的进程控制块。其源码如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;pick_next_task&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; rq *rq, &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *prev)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; sched_class *&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; = &amp;amp;fair_sched_class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (likely(prev-&amp;gt;sched_class == &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		   rq-&amp;gt;nr_running == rq-&amp;gt;cfs.h_nr_running)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p = fair_sched_class.pick_next_task(rq, prev); &lt;span class=&quot;comment&quot;&gt;//进程调度算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (unlikely(p == RETRY_TASK))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; again;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;/* assumes fair_sched_class-&amp;gt;next == idle_sched_class */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (unlikely(!p))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p = idle_sched_class.pick_next_task(rq, prev); &lt;span class=&quot;comment&quot;&gt;//进程调度算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;again:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for_each_class(&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p = &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;-&amp;gt;pick_next_task(rq, prev); &lt;span class=&quot;comment&quot;&gt;//进程调度算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (unlikely(p == RETRY_TASK))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; again;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	BUG(); &lt;span class=&quot;comment&quot;&gt;/* the idle class will always have a runnable task */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见，该函数中3次调用了名为pick_next_task的函数。事实上，这3个pick_next_task均为函数指针，指向了3个不同的函数。也就是说，在不同的情况下，linux会选择不同的算法来获取下一个要执行的进程。&lt;/p&gt;
&lt;h2 id=&quot;2-4-context-switch函数和switch-to函数&quot;&gt;&lt;a href=&quot;#2-4-context-switch函数和switch-to函数&quot; class=&quot;headerlink&quot; title=&quot;2.4 context_switch函数和switch_to函数&quot;&gt;&lt;/a&gt;2.4 context_switch函数和switch_to函数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;context_switch&lt;/code&gt;函数位于&lt;code&gt;kernel/sched/core.c&lt;/code&gt;，其主要功能是执行进程调度。此处不再列举其源码，因为在源码中，最重要的一条语句即为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;switch_to(prev, next, prev);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该语句的任务是执行进程上下文的切换。对于不同的CPU指令集，进程上下文切换的步骤也不同，因此&lt;code&gt;switch_to&lt;/code&gt;是存放在&lt;code&gt;arch&lt;/code&gt;目录中的。对于x86指令集，该函数位于&lt;code&gt;arch/x86/include/asm/switch_to.h&lt;/code&gt;，其源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; switch_to(prev, next, last)					\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do &amp;#123;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	unsigned long ebx, ecx, edx, esi, edi;				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;span class=&quot;string&quot;&gt;&quot;pushfl\n\t&quot;&lt;/span&gt;		&lt;span class=&quot;comment&quot;&gt;/* 保存进程标志 */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;pushl %%ebp\n\t&quot;&lt;/span&gt;		&lt;span class=&quot;comment&quot;&gt;/* 保存prev进程的堆栈底端   */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;movl %%esp,%[prev_sp]\n\t&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 将prev进程的堆栈信息存入prev的进程控制块中   */&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;movl %[next_sp],%%esp\n\t&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 从next进程的进程控制块中调出堆栈位置信息   */&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;movl $1f,%[prev_ip]\n\t&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 将$1位置存入prev的进程控制块，作为下次调用的起点   */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;pushl %[next_ip]\n\t&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 将next进程的当前语句压栈   */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     __switch_canary					\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;jmp __switch_to\n&quot;&lt;/span&gt;	&lt;span class=&quot;comment&quot;&gt;/* 跳转到__switch_to函数，由于没有执行call语句，因此堆栈中的返回位置是next_ip  */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;comment&quot;&gt;/* 从__switch_to中返回时，进程上下文已切换至next进程，并执行$1位置 */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;1:\t&quot;&lt;/span&gt;					&lt;span class=&quot;comment&quot;&gt;/* $1位置，进程继续执行的位置 */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;popl %%ebp\n\t&quot;&lt;/span&gt;		&lt;span class=&quot;comment&quot;&gt;/* 弹出next进程的堆栈底端   */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;string&quot;&gt;&quot;popfl\n&quot;&lt;/span&gt;			&lt;span class=&quot;comment&quot;&gt;/* 恢复进程标志 */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     &lt;span class=&quot;comment&quot;&gt;/* output parameters */&lt;/span&gt;				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     : [prev_sp] &lt;span class=&quot;string&quot;&gt;&quot;=m&quot;&lt;/span&gt; (prev-&amp;gt;thread.sp),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       [prev_ip] &lt;span class=&quot;string&quot;&gt;&quot;=m&quot;&lt;/span&gt; (prev-&amp;gt;thread.ip),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;string&quot;&gt;&quot;=a&quot;&lt;/span&gt; (last),					\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;comment&quot;&gt;/* clobbered output registers: */&lt;/span&gt;		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;string&quot;&gt;&quot;=b&quot;&lt;/span&gt; (ebx), &lt;span class=&quot;string&quot;&gt;&quot;=c&quot;&lt;/span&gt; (ecx), &lt;span class=&quot;string&quot;&gt;&quot;=d&quot;&lt;/span&gt; (edx),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;string&quot;&gt;&quot;=S&quot;&lt;/span&gt; (esi), &lt;span class=&quot;string&quot;&gt;&quot;=D&quot;&lt;/span&gt; (edi)				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       							\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       __switch_canary_oparam				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;comment&quot;&gt;/* input parameters: */&lt;/span&gt;				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     : [next_sp]  &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (next-&amp;gt;thread.sp),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       [next_ip]  &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (next-&amp;gt;thread.ip),		\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       							\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       &lt;span class=&quot;comment&quot;&gt;/* regparm parameters for __switch_to(): */&lt;/span&gt;	\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       [prev]     &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; (prev),				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       [next]     &lt;span class=&quot;string&quot;&gt;&quot;d&quot;&lt;/span&gt; (next)				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		       __switch_canary_iparam				\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;									\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		     : &lt;span class=&quot;comment&quot;&gt;/* reloaded segment registers */&lt;/span&gt;			\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;string&quot;&gt;&quot;memory&quot;&lt;/span&gt;);					\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段程序分为保存现场和恢复现场两部分。保存现场的内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;压栈保存flag&lt;/li&gt;
&lt;li&gt;压栈保存ebp信息&lt;/li&gt;
&lt;li&gt;将sp存入进程控制块的sp中&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;$1&lt;/code&gt;存入进程控制块的ip中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里值得注意的是：保存ip信息时，并没有把当前的ip存入进程控制块，这是因为，下次恢复现场的时候，并不希望从当前ip处执行，而是希望从当前ip的后面几句，即&lt;code&gt;$1&lt;/code&gt;处开始执行。&lt;/p&gt;
&lt;p&gt;恢复现场的内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从进程控制块中取出sp&lt;/li&gt;
&lt;li&gt;从进程控制块中取出ip并压栈&lt;/li&gt;
&lt;li&gt;用jmp而不是call调用__switch_to函数（用call时会将当前ip压栈，这并不是我们期望的，因为next_ip已经压栈了），在函数返回时的ret将栈顶的ip弹出到程序指针处&lt;/li&gt;
&lt;li&gt;弹栈恢复ebp信息&lt;/li&gt;
&lt;li&gt;弹栈恢复flag信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;理解这段程序时，应该注意：next进程在上一次切换时，也执行了保存现场的语句，因此next进程的现场和prev进程的现场在结构上是相同的。&lt;/p&gt;
&lt;h1 id=&quot;3-小结&quot;&gt;&lt;a href=&quot;#3-小结&quot; class=&quot;headerlink&quot; title=&quot;3 小结&quot;&gt;&lt;/a&gt;3 小结&lt;/h1&gt;&lt;p&gt;在linux系统中，进程调度是很重要的一部分。linux系统的一般执行过程即为“从一个进程切换到另一个进程”。进程切换通过调用schedule函数来完成，其中最主要的内容即为进程上下文的切换。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;schedule是linux中的一个内核函数，用于实现进程调度。该函数由内核线程在合适的时机调用，完成进程上下文的切换。本文从源码的角度分析了schedule函数的执行过程，尤其是进程上下文的切换过程。本文所分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/categories/linux/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="进程" scheme="http://cxsmarkchan.github.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="schedule" scheme="http://cxsmarkchan.github.com/tags/schedule/"/>
    
  </entry>
  
  <entry>
    <title>linux源码分析：execve加载可执行文件</title>
    <link href="http://cxsmarkchan.github.com/2016/04/10/linux-execve/"/>
    <id>http://cxsmarkchan.github.com/2016/04/10/linux-execve/</id>
    <published>2016-04-10T06:29:42.000Z</published>
    <updated>2017-09-25T22:52:56.950Z</updated>
    
    <content type="html">&lt;p&gt;execve是linux中一个重要的系统调用，它用于将一个可执行文件加载如内存中并执行。在执行shell命令时，就会调用execve函数。有意思的是，execve并未创建新的进程，而是会把当前进程覆盖。本文分析execve的实现过程，以加深对linux可执行文件加载过程的理解。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容： cxsmarkchan 陈晓爽&lt;br&gt;转载请注明出处&lt;br&gt;&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:ustcX+USTC001+_/about&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux内核分析&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-execve的使用方法&quot;&gt;&lt;a href=&quot;#1-execve的使用方法&quot; class=&quot;headerlink&quot; title=&quot;1 execve的使用方法&quot;&gt;&lt;/a&gt;1 execve的使用方法&lt;/h1&gt;&lt;p&gt;execve的调用格式如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * filename,&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; argv[ ],&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; envp[ ])&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;按照linux一切皆文件的思想，加载可执行程序，实际上是把一个二进制文件加载入内存。其中，&lt;code&gt;filename&lt;/code&gt;为可执行文件名，&lt;code&gt;argv&lt;/code&gt;为输入的参数，&lt;code&gt;envp&lt;/code&gt;为环境参数。在执行shell命令时，我们只需输入filename和argv，而envp则由系统自动赋值。&lt;br&gt;为了演示execve的使用，首先看下面一段C代码：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* str[] = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;ls&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execve(&lt;span class=&quot;string&quot;&gt;&quot;/bin/ls&quot;&lt;/span&gt;, str, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ls done!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码中用execve调用了linux的ls进程，用于显示当前目录下的文件。假设当前目录下有&lt;code&gt;test.cpp&lt;/code&gt;和&lt;code&gt;a.out&lt;/code&gt;两个文件，猜一下这段程序的运行结果是什么呢？从直觉上看，似乎应该是这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test.cpp a.out&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ls done!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但实际上，运行结果是这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test.cpp a.out&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行完execve后，那句printf语句为什么没有被执行呢？这正是execve的神奇之处：它没有创建新进程，而是用新加载的可执行文件把当前进程覆盖了！因此，执行完execve后，printf语句早已不存在。&lt;br&gt;因此，调用execve的时候，我们通常用如下程序，先fork一个子进程，并在子进程中加载可执行文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char* str[] = &amp;#123;&amp;quot;ls&amp;quot;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int pid = fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(pid == 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        execve(&amp;quot;/bin/ls&amp;quot;, str, NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wait(NULL); // 等待子进程返回&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;ls done!\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段程序就可以得到预期的输出结果，即先输出ls的结果，再输出&lt;code&gt;ls done!&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;2-execve源码分析&quot;&gt;&lt;a href=&quot;#2-execve源码分析&quot; class=&quot;headerlink&quot; title=&quot;2 execve源码分析&quot;&gt;&lt;/a&gt;2 execve源码分析&lt;/h1&gt;&lt;h2 id=&quot;2-1-从execve到exec-binprm&quot;&gt;&lt;a href=&quot;#2-1-从execve到exec-binprm&quot; class=&quot;headerlink&quot; title=&quot;2.1 从execve到exec_binprm&quot;&gt;&lt;/a&gt;2.1 从execve到exec_binprm&lt;/h2&gt;&lt;p&gt;execve位于内核源码的&lt;code&gt;fs/exec.c&lt;/code&gt;，其定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SYSCALL_DEFINE3(execve,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *, filename,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __user *, argv,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __user *, envp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; do_execve(getname(filename), argv, envp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;do_execve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; filename *filename,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __user *__argv,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; __user *&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; __user *__envp)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_arg_ptr argv = &amp;#123; .ptr.native = __argv &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_arg_ptr envp = &amp;#123; .ptr.native = __envp &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; do_execve_common(filename, argv, envp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见sys_execve函数调用了do_execve函数，而后者又调用了do_execve_common函数。do_execve_common函数中同样定义于&lt;code&gt;fs/exec.c&lt;/code&gt;中，它包含了execve的主体部分，代码较长，我们只分析其中的主干部分：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;do_execve_common&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; filename *filename,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_arg_ptr argv,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; user_arg_ptr envp)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; linux_binprm *bprm; &lt;span class=&quot;comment&quot;&gt;//bprm用于维护程序执行的相关参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; file *file;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm = kzalloc(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(*bprm), GFP_KERNEL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = prepare_bprm_creds(bprm); &lt;span class=&quot;comment&quot;&gt;//分配creds结构体，处理锁信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	check_unsafe_exec(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    current-&amp;gt;in_execve = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//表明当前进程正在执行新程序，这个在进程调度中有意义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	file = do_open_exec(filename); &lt;span class=&quot;comment&quot;&gt;//打开文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sched_exec(); &lt;span class=&quot;comment&quot;&gt;//进程调度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;file = file;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;filename = bprm-&amp;gt;interp = filename-&amp;gt;name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = bprm_mm_init(bprm); &lt;span class=&quot;comment&quot;&gt;//初始化内存映射&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//以下内容为填充bprm，录入输入参数、环境参数等信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;argc = count(argv, MAX_ARG_STRINGS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;envc = count(envp, MAX_ARG_STRINGS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = prepare_binprm(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = copy_strings_kernel(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &amp;amp;bprm-&amp;gt;filename, bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bprm-&amp;gt;exec = bprm-&amp;gt;p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = copy_strings(bprm-&amp;gt;envc, envp, bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = copy_strings(bprm-&amp;gt;argc, argv, bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//装载程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    retval = exec_binprm(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//还原信息和释放内存等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    current-&amp;gt;in_execve = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    free_bprm(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;在do_execve_common中，最重要的工作是构建bprm结构体&lt;/strong&gt;。bprm结构体中包含了装载应用程序需要的所有信息，这些信息正是在do_execve_common中录入。这里应该重点关注bprm-&amp;gt;p，它代表了应用程序堆栈的当前位置。我们知道，在调用一个应用程序时，相关参数实际上是main函数的参数，而参数的传入方式是通过堆栈传递。因此，在初始化应用程序的时候，必须首先把参数压栈。这个操作是在copy_strings_kernel和copy_strings函数中完成的(这些函数中会修改bprm-&amp;gt;p)。当这些操作完成后，bprm-&amp;gt;p已经指向了当前的堆栈顶端，因此装载可执行程序时，只需要把堆栈指向bprm-&amp;gt;p，即可顺利执行。&lt;/p&gt;
&lt;p&gt;构建完bprm后，do_execve_common调用了exec_binprm函数，装载应用程序。该函数定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// exec_binprm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// position: fs/exec.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static int exec_binprm(struct linux_binprm *bprm)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pid_t old_pid, old_vpid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	/* Need to fetch pid before load_binary changes it */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	old_pid = current-&amp;gt;pid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rcu_read_lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	old_vpid = task_pid_nr_ns(current, task_active_pid_ns(current-&amp;gt;parent));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rcu_read_unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ret = search_binary_handler(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (ret &amp;gt;= 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		audit_bprm(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		trace_sched_process_exec(current, old_pid, bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ptrace_event(PTRACE_EVENT_EXEC, old_vpid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		proc_exec_connector(current);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中最关键的语句是search_binary_handler，其功能是根据可执行文件的格式，查找相应的处理程序。&lt;/strong&gt;其定义如下(只列举了重要语句)：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;search_binary_handler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; linux_binprm *bprm)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; linux_binfmt *fmt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = security_bprm_check(bprm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	read_lock(&amp;amp;binfmt_lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 查找合适的处理程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	list_for_each_entry(fmt, &amp;amp;formats, lh) &amp;#123; &lt;span class=&quot;comment&quot;&gt;//遍历formats列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!try_module_get(fmt-&amp;gt;module)) &lt;span class=&quot;comment&quot;&gt;//判断文件格式是否匹配&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		read_unlock(&amp;amp;binfmt_lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bprm-&amp;gt;recursion_depth++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		retval = fmt-&amp;gt;load_binary(bprm); &lt;span class=&quot;comment&quot;&gt;//处理程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		put_binfmt(fmt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bprm-&amp;gt;recursion_depth--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	read_unlock(&amp;amp;binfmt_lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该函数中用到了list_for_each_entry宏，这里不分析该宏的具体实现，只需知道它用于遍历formats中所有的列表项。formats列表中的每一项都是一个linux_binfmt结构体，代表了一种文件格式。每个变量中有一个名为load_binary的函数指针，指向相应的加载函数。例如，linux中最常用的ELF格式文件，其对应的加载函数即为load_elf_binary。这种实现方式类似于C++中的多态，也比较灵活，但内核实现需要借助很多宏，理解起来不如C++方便。&lt;br&gt;&lt;strong&gt;在search_binary_handler中，formats被遍历，当找到匹配的文件格式时，load_binary函数即被调用。&lt;/strong&gt;接下来，我们只分析load_elf_binary的源码。&lt;/p&gt;
&lt;h2 id=&quot;2-2-load-elf-binary&quot;&gt;&lt;a href=&quot;#2-2-load-elf-binary&quot; class=&quot;headerlink&quot; title=&quot;2.2 load_elf_binary&quot;&gt;&lt;/a&gt;2.2 load_elf_binary&lt;/h2&gt;&lt;p&gt;load_elf_binary位于&lt;code&gt;fs/binfmt_elf.c&lt;/code&gt;，其代码很长，因为它需要对ELF格式的二进制文件进行解析。我们同样只看其中最主干的部分：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;load_elf_binary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; linux_binprm *bprm)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//大量变量定义，此处未完全列举&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * elf_interpreter = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; elf_entry; &lt;span class=&quot;comment&quot;&gt;//进程入口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pt_regs *regs = current_pt_regs(); &lt;span class=&quot;comment&quot;&gt;//当前的进程信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; elfhdr elf_ex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; elfhdr interp_elf_ex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; *loc; &lt;span class=&quot;comment&quot;&gt;//进程执行信息，包括进程入口等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;////////////////////////////////////////////&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//文件解析工作，此处省略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;////////////////////////////////////////////&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (elf_interpreter) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 动态链接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; interp_map_addr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		elf_entry = load_elf_interp(&amp;amp;loc-&amp;gt;interp_elf_ex,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					    interpreter,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					    &amp;amp;interp_map_addr,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					    load_bias);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		reloc_func_desc = interp_load_addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		allow_write_access(interpreter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fput(interpreter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		kfree(elf_interpreter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 静态链接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		elf_entry = loc-&amp;gt;elf_ex.e_entry;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	kfree(elf_phdata);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	set_binfmt(&amp;amp;elf_format);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/////////////////////////////////////////////////////////&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//此处省略了设置内存映射的相关内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/////////////////////////////////////////////////////////&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	start_thread(regs, elf_entry, bprm-&amp;gt;p); &lt;span class=&quot;comment&quot;&gt;//启动进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	retval = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;该函数主要做了3部分工作：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;把可执行文件读入内存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据读入的elf文件信息，设置可执行文件的入口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动线程&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上述代码可见，在设置可执行文件入口的时候，需要根据程序是否有动态链接行为，决定进程的入口位置，此处不再展开说明。&lt;/p&gt;
&lt;h2 id=&quot;2-3-start-thread&quot;&gt;&lt;a href=&quot;#2-3-start-thread&quot; class=&quot;headerlink&quot; title=&quot;2.3 start_thread&quot;&gt;&lt;/a&gt;2.3 start_thread&lt;/h2&gt;&lt;p&gt;经过一番曲折，终于到了execve程序的末尾。上一节中load_elf_binary最后有这么一句话：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;start_thread(regs, elf_entry, bprm-&amp;gt;p);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个语句即为启动新加载的程序了。在x86 32位系统中，start_thread定义在&lt;code&gt;arch/x86/kernel/process_32.c&lt;/code&gt;中，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;start_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pt_regs *regs, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; new_ip, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; new_sp)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	set_user_gs(regs, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;fs		= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;ds		= __USER_DS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;es		= __USER_DS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;ss		= __USER_DS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;cs		= __USER_CS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;ip		= new_ip;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;sp		= new_sp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	regs-&amp;gt;flags		= X86_EFLAGS_IF;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	set_thread_flag(TIF_NOTIFY_RESUME);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意我们传入的3个参数，第1个参数regs即为当前进程的注册信息，在load_elf_binary中定义。第2个参数new_ip是入口指令位置，在load_elf_binary中，由elf_entry指定。第3个参数new_sp是堆栈位置，传入参数为bprm-&amp;gt;p，这个信息很早的时候，在do_execve_common函数中即设置完毕。有了这3个参数，start_thread可以顺利执行，可执行程序也就加载完毕。&lt;/p&gt;
&lt;h1 id=&quot;3-小结&quot;&gt;&lt;a href=&quot;#3-小结&quot; class=&quot;headerlink&quot; title=&quot;3 小结&quot;&gt;&lt;/a&gt;3 小结&lt;/h1&gt;&lt;p&gt;linux在装载和启动一个可执行程序的时候，主要做了如下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建linux_binprm结构体，装载文件名、参数等信息，并完成堆栈信息的记录。&lt;/li&gt;
&lt;li&gt;根据可执行文件的格式信息，查找相应的解析和加载程序。对于ELF程序，即为调用load_elf_binary函数。&lt;/li&gt;
&lt;li&gt;在load_binary函数中，设置可执行程序的入口指令位置，并调用start_kernel，装入新的ip和sp，完成可执行程序的启动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，execve是在当前进程（调用execve函数的进程）上加载可执行文件，加载完毕后，原进程即被覆盖。如果不希望被覆盖，应该用fork创建新进程，再调用execve函数。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;execve是linux中一个重要的系统调用，它用于将一个可执行文件加载如内存中并执行。在执行shell命令时，就会调用execve函数。有意思的是，execve并未创建新的进程，而是会把当前进程覆盖。本文分析execve的实现过程，以加深对linux可执行文件加载过程的理解。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot;&gt;这里&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/categories/linux/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="execve" scheme="http://cxsmarkchan.github.com/tags/execve/"/>
    
      <category term="进程" scheme="http://cxsmarkchan.github.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux源码分析：fork复制进程</title>
    <link href="http://cxsmarkchan.github.com/2016/04/03/linux-fork/"/>
    <id>http://cxsmarkchan.github.com/2016/04/03/linux-fork/</id>
    <published>2016-04-04T01:04:54.000Z</published>
    <updated>2017-09-25T22:52:56.938Z</updated>
    
    <content type="html">&lt;p&gt;fork函数是linux系统的一个API，用于将当前进程复制，并创建一个新的进程。本文从linux源码的角度分析fork的实现过程，并学习linux创建新进程的过程。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容：cxsmarkchan 陈晓爽&lt;br&gt;转载请注明出处&lt;br&gt;&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Linux内核分析》MOOC课程&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-fork函数&quot;&gt;&lt;a href=&quot;#1-fork函数&quot; class=&quot;headerlink&quot; title=&quot;1 fork函数&quot;&gt;&lt;/a&gt;1 fork函数&lt;/h1&gt;&lt;p&gt;在Linux系统下书写如下C语言代码：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid = fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed!&quot;&lt;/span&gt;\n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This is Child Process!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This is Parent Process!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样一段程序的执行结果如下（注意两条语句的执行顺序并不完全确定）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;This is Parent Process!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is Child Process!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有意思的事情是：两条输出语句被写在if-elseif-else语句的不同分支中，但输出时竟然两条语句均输出了！&lt;br&gt;这正是fork函数的作用：它把当前进程状态和相关数据都复制了一份，系统中有两个进程在运行。新生成的进程与原进程的状态完全相同，因此它也会“认为”自己调用了fork函数，并从fork()函数中返回。但是，两个进程的fork函数返回值并不相等。对于父进程，返回的pid是其子进程的pid。对于子进程，返回的pid则是0。因此，会出现两条输出语句。&lt;br&gt;接下来，我们会分析fork语句在linux源码中的实现。我们关心的重点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新进程的堆栈空间是如何分配的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新进程如何保证与原进程有相同的堆栈状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新进程的起始执行点如何确定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何使新进程的返回值和原进程不同**&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-fork的源码分析&quot;&gt;&lt;a href=&quot;#2-fork的源码分析&quot; class=&quot;headerlink&quot; title=&quot;2 fork的源码分析&quot;&gt;&lt;/a&gt;2 fork的源码分析&lt;/h1&gt;&lt;h2 id=&quot;2-1-linux的进程信息管理&quot;&gt;&lt;a href=&quot;#2-1-linux的进程信息管理&quot; class=&quot;headerlink&quot; title=&quot;2.1 linux的进程信息管理&quot;&gt;&lt;/a&gt;2.1 linux的进程信息管理&lt;/h2&gt;&lt;p&gt;linux系统为每个进程维护了一个task_struct类型的结构体变量，用于存储进程相关信息。task_struct结构定义于&lt;code&gt;include/linux/sched.h&lt;/code&gt;，其代码约400行，包含进程的id、当前状态、内存信息、文件系统信息等。这里我们仅关系以下内容：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid; &lt;span class=&quot;comment&quot;&gt;//进程id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_struct thread; &lt;span class=&quot;comment&quot;&gt;//进程当前状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，进程的id用于对进程进行唯一标识，进程的内核堆栈是操作系统为每个进程维护的一段空间（其内部包含用户堆栈和寄存器信息等），进程的当前状态则也是一个结构体，包含了进程的堆栈信息、当前运行位置、锁信息等。thread_struct在各种硬件环境中实现也不相同，在x86系统中，thread_struct定义于&lt;code&gt;arch/x86/include/asm/processor.h&lt;/code&gt;。下面列出我们关心的内容：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_struct&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sp; &lt;span class=&quot;comment&quot;&gt;//堆栈顶端&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ip; &lt;span class=&quot;comment&quot;&gt;//当前运行位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因此，在创建新进程的时候，也需要给新进程分配id，分配内核堆栈stack，并初始化进程状态thread（在fork函数中，初始化的新进程状态应该与原进程完全相同，除了fork函数的返回值）。&lt;/p&gt;
&lt;h2 id=&quot;2-2-fork调用的全过程&quot;&gt;&lt;a href=&quot;#2-2-fork调用的全过程&quot; class=&quot;headerlink&quot; title=&quot;2.2 fork调用的全过程&quot;&gt;&lt;/a&gt;2.2 fork调用的全过程&lt;/h2&gt;&lt;p&gt;fork函数并不是一个普通的函数，而是一个系统调用，而系统调用是一个软件中断，在fork函数的调用过程中（中断返回前），会生成两个进程，因此生成的两个进程都仍处在中断状态，需要从中断状态返回。调用fork函数的父进程从中断过程返回是可以理解的，只需经过恢复现场的工作就可以了。但新生成的子进程，如何保证其初始化在中断状态，并从中断状态中返回呢？进一步地，如何让两个进程的返回值不相等呢？&lt;br&gt;下面的图可以简要地说明这种情况：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-flowchart.jpg&quot; alt=&quot;fork调用示意图&quot;&gt;&lt;br&gt;在该图中可以看出，父进程仍然是正常的系统调用处理过程，但新建的新进程，则是复制了父进程的状态，并把当前语句设置在&lt;code&gt;ret_from_fork&lt;/code&gt;标签处，该标签处执行一些初始化语句后，就跳转到&lt;code&gt;syscall_exit_work&lt;/code&gt;处，退出中断状态。由于子进程和父进程的堆栈完全相同，因此返回的位置也完全相同。&lt;br&gt;而唯一不同的是两个进程的返回值，这一点的实现则是靠&lt;code&gt;ax&lt;/code&gt;寄存器。&lt;code&gt;ax&lt;/code&gt;寄存器中存储了系统调用的返回值，对于新进程来说，在&lt;code&gt;copy_thread&lt;/code&gt;函数中将新进程的&lt;code&gt;ax&lt;/code&gt;寄存器值设置为0，因此新进程的返回为0。&lt;br&gt;各个函数的位置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system_call: &lt;code&gt;arch/x86/kernel/entry_32.S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;sys_fork: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;do_fork: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy_process: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;dup_task_struct: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy_thread: &lt;code&gt;arch/x86/kernel/process_32.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ret_from_kernel: &lt;code&gt;arch/x86/kernel/entry_32.S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下会重点分析dup_task_struct和copy_thread函数，以及ret_from_kernel过程&lt;/p&gt;
&lt;h2 id=&quot;2-3-相关的函数分析&quot;&gt;&lt;a href=&quot;#2-3-相关的函数分析&quot; class=&quot;headerlink&quot; title=&quot;2.3 相关的函数分析&quot;&gt;&lt;/a&gt;2.3 相关的函数分析&lt;/h2&gt;&lt;h3 id=&quot;2-3-1-dup-task-struct：创建进程&quot;&gt;&lt;a href=&quot;#2-3-1-dup-task-struct：创建进程&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 dup_task_struct：创建进程&quot;&gt;&lt;/a&gt;2.3.1 dup_task_struct：创建进程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;dup_task_struct用于创建一个新的进程，并把当前进程的信息复制到新进程（注意当前进程的运行状态不是在这里复制）。&lt;/strong&gt;部分重要的源码和我的注释如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *&lt;span class=&quot;title&quot;&gt;dup_task_struct&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *orig)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *tsk; &lt;span class=&quot;comment&quot;&gt;//新进程的进程管理结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_info *ti; &lt;span class=&quot;comment&quot;&gt;//新进程的内核堆栈结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; node = tsk_fork_get_node(orig); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; err;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tsk = alloc_task_struct_node(node); &lt;span class=&quot;comment&quot;&gt;//分配进程管理结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!tsk)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ti = alloc_thread_info_node(tsk, node); &lt;span class=&quot;comment&quot;&gt;//开辟内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!ti)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; free_tsk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	err = arch_dup_task_struct(tsk, orig); &lt;span class=&quot;comment&quot;&gt;//把orig的内容拷贝给tsk&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; free_ti;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tsk-&amp;gt;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt; = ti; &lt;span class=&quot;comment&quot;&gt;//把内核堆栈赋给tsk&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	setup_thread_stack(tsk, orig); &lt;span class=&quot;comment&quot;&gt;//初始化内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tsk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;free_ti:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free_thread_info(ti);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;free_tsk:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free_task_struct(tsk);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-copy-thread：复制进程状态&quot;&gt;&lt;a href=&quot;#2-3-2-copy-thread：复制进程状态&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 copy_thread：复制进程状态&quot;&gt;&lt;/a&gt;2.3.2 copy_thread：复制进程状态&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;copy_thread用于把原进程的状态和堆栈拷贝到新进程，并设置返回值为0。&lt;/strong&gt;部分重要的源码和我的注释如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copy_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; clone_flags, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; sp,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; arg, &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pt_regs *childregs = task_pt_regs(p); &lt;span class=&quot;comment&quot;&gt;// 获取新进程的内核堆栈指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;thread.sp = (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;) childregs; &lt;span class=&quot;comment&quot;&gt;// 将新进程的堆栈设置为新分配的堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *childregs = *current_pt_regs(); &lt;span class=&quot;comment&quot;&gt;// 复制所有的内核堆栈信息，包括寄存器信息和堆栈信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    childregs-&amp;gt;ax = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 这句话把ax设置为0，因此新进程的系统调用返回值为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    childregs-&amp;gt;sp = sp; &lt;span class=&quot;comment&quot;&gt;//复制当前堆栈信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;thread.ip = (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;) ret_from_fork; &lt;span class=&quot;comment&quot;&gt;// 设置新进程的入口位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见，该函数执行完毕后，新进程的堆栈和入口都已经确定，新进程启动时将处在中断状态，而中断返回值为0.&lt;/p&gt;
&lt;h3 id=&quot;2-3-3-ret-from-fork：退出中断&quot;&gt;&lt;a href=&quot;#2-3-3-ret-from-fork：退出中断&quot; class=&quot;headerlink&quot; title=&quot;2.3.3 ret_from_fork：退出中断&quot;&gt;&lt;/a&gt;2.3.3 ret_from_fork：退出中断&lt;/h3&gt;&lt;p&gt;这是新进程的第一条语句，当进程调度把CPU控制权交给新进程时，就会从该处向下执行。相关内容如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ENTRY(ret_from_fork)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFI_STARTPROC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pushl_cfi %eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	call schedule_tail&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	GET_THREAD_INFO(%ebp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	popl_cfi %eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pushl_cfi $0x0202		# Reset kernel eflags&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	popfl_cfi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	jmp syscall_exit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFI_ENDPROC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;END(ret_from_fork)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中有一句&lt;code&gt;jmp syscall_exit&lt;/code&gt;，而&lt;code&gt;syscall_exit&lt;/code&gt;位于系统调用函数刚结束，正准备退出中断的位置。此时&lt;code&gt;ax&lt;/code&gt;寄存器中存储了系统调用的返回值，而新进程的堆栈已经和原进程完全相同，因此会和原进程在相同的位置返回。到这里，也就得到了我们在第1节看到的结果：子进程将进入&lt;code&gt;pid == 0&lt;/code&gt;的分支。&lt;/p&gt;
&lt;h1 id=&quot;3-用gdb跟踪fork&quot;&gt;&lt;a href=&quot;#3-用gdb跟踪fork&quot; class=&quot;headerlink&quot; title=&quot;3 用gdb跟踪fork&quot;&gt;&lt;/a&gt;3 用gdb跟踪fork&lt;/h1&gt;&lt;p&gt;本节中，我们用gdb跟踪fork函数，以验证我们前面的结论。这里的实验平台采用&lt;a href=&quot;https://shiyanlou.com/courses/195&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验楼Linux内核分析&lt;/a&gt;的第6个实验：分析linux内核创建一个新进程的过程。&lt;br&gt;进入实验平台，输入如下代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd LinuxKernel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm menu -rf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/mengning/menu.git权威指南&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd menu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv test_fork.c test.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make rootfs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;即可看到启动的实验系统，在系统中输入fork命令，则可以看到如下运行结果：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-process.jpg&quot; alt=&quot;实验系统fork&quot;&gt;&lt;br&gt;为了能够用gdb跟踪，输入如下命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd ../rootfs.img -s -S&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再重启一个窗口，输入如下命令：&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ~/LinuxKernel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;file linux-3.18.6/vmlinux&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target remote:1234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c &lt;span class=&quot;comment&quot;&gt;#让程序执行一步&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;^C &lt;span class=&quot;comment&quot;&gt;#中断程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;#设置断点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;_fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b copy_process&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b dup_task_struct&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b copy_thread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b ret_from_fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置以上断点后，在模拟系统的控制台下键入fork，就可以通过断点跟踪fork的执行过程。这里就不展示所有的截图了，大致如下图：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-break.jpg&quot; alt=&quot;断点跟踪&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;4-小结&quot;&gt;&lt;a href=&quot;#4-小结&quot; class=&quot;headerlink&quot; title=&quot;4 小结&quot;&gt;&lt;/a&gt;4 小结&lt;/h1&gt;&lt;p&gt;Linux调用fork复制一个新进程需要经过如下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入系统中断，调用sys_fork函数&lt;/li&gt;
&lt;li&gt;sys_fork调用do_fork函数&lt;/li&gt;
&lt;li&gt;do_fork调用copy_process函数&lt;/li&gt;
&lt;li&gt;copy_process调用dup_task_struct函数，将父进程的task_struct拷贝给子进程，并为子进程创建单独的进程控制块和内核堆栈空间。新的进程就在这里诞生了。&lt;/li&gt;
&lt;li&gt;copy_process调用copy_thread函数，把父进程的堆栈信息复制给子进程，并将ax寄存器设置为0。然后，子进程的入口地点被设置为&lt;code&gt;ret_from_fork&lt;/code&gt;标签。&lt;/li&gt;
&lt;li&gt;父进程的系统调用逐层返回，返回值为子进程的pid。&lt;/li&gt;
&lt;li&gt;子进程在获得CPU控制权时，会执行&lt;code&gt;ret_from_fork&lt;/code&gt;，而&lt;code&gt;ret_from_fork&lt;/code&gt;会跳转到&lt;code&gt;syscall_exit&lt;/code&gt;标签，退出中断。由于&lt;code&gt;ax&lt;/code&gt;设置为0，所以系统调用返回0。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;fork函数是linux系统的一个API，用于将当前进程复制，并创建一个新的进程。本文从linux源码的角度分析fork的实现过程，并学习linux创建新进程的过程。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/categories/linux/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="fork" scheme="http://cxsmarkchan.github.com/tags/fork/"/>
    
      <category term="进程创建" scheme="http://cxsmarkchan.github.com/tags/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用：32位和64位的区别</title>
    <link href="http://cxsmarkchan.github.com/2016/04/02/asm-syscall-64/"/>
    <id>http://cxsmarkchan.github.com/2016/04/02/asm-syscall-64/</id>
    <published>2016-04-02T14:45:20.000Z</published>
    <updated>2017-09-25T22:52:56.926Z</updated>
    
    <content type="html">&lt;p&gt;最近在学习系统调用，一段用asm内联汇编写的简单程序始终得不出正确的结果，后来了解到这是32位平台和64位平台的系统调用方法不同的原因。在此列出相关的程序和我的理解。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;原创内容：cxsmarkchan&lt;br&gt;转载请注明出处&lt;br&gt;首次发表于csdn：&lt;a href=&quot;http://blog.csdn.net/cxsmarkchan/article/details/50987222&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux asm系统调用：32位和64位的区别&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;程序代码和问题&quot;&gt;&lt;a href=&quot;#程序代码和问题&quot; class=&quot;headerlink&quot; title=&quot;程序代码和问题&quot;&gt;&lt;/a&gt;程序代码和问题&lt;/h1&gt;&lt;p&gt;首先看如下一段简单的C程序（&lt;code&gt;test.cpp&lt;/code&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[] = &lt;span class=&quot;string&quot;&gt;&quot;Hello\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	write(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, str, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段程序调用了write函数，其接口为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int write(int fd /*输出位置句柄*/, const char* src /*输出首地址*/， int len /*长度*/)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;fd为0则表示输出到控制台。因此上述程序的执行结果为：向控制台输出一个长度为6的字符串&lt;code&gt;&amp;quot;Hello\n&amp;quot;&lt;/code&gt;。&lt;br&gt;在控制台调用&lt;code&gt;gcc test.cpp&lt;/code&gt;，可以正确输出。&lt;br&gt;为了更好地理解在汇编代码下的系统调用过程，可把上述代码改写成内联汇编的格式（具体语法可参考上一篇博客：&lt;a href=&quot;http://cxsmarkchan.github.io/2016/04/01/asm-syscall&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用asm内联汇编实现系统调用&lt;/a&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_A.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char str[] = &amp;quot;Hello\n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&amp;quot;a&amp;quot;(4), &amp;quot;b&amp;quot;(0), &amp;quot;c&amp;quot;(str), &amp;quot;d&amp;quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，4是write函数的系统调用号，ebx/ecx/edx是系统调用的前三个参数。&lt;br&gt;&lt;strong&gt;然而，执行&lt;code&gt;gcc test_asm_A.cpp&lt;/code&gt;编译后，再运行程序，发现程序没有任何输出&lt;/strong&gt;。一个很奇怪的问题是，如果采用如下&lt;code&gt;test_asm_B.cpp&lt;/code&gt;的写法，则程序可以正常地输出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_B.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char *str = (char*)malloc(7 * sizeof(char));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	strcpy(str, &amp;quot;Hello\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&amp;quot;a&amp;quot;(4), &amp;quot;b&amp;quot;(0), &amp;quot;c&amp;quot;(str), &amp;quot;d&amp;quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两段代码唯一的区别，是&lt;code&gt;test_asm_A.cpp&lt;/code&gt;中的&lt;code&gt;str&lt;/code&gt;存储在栈空间，而&lt;code&gt;test_asm_B.cpp&lt;/code&gt;中的&lt;code&gt;str&lt;/code&gt;存储在堆空间。&lt;/strong&gt;&lt;br&gt;那么，为什么存储位置的不同会造成完全不同的结果呢？&lt;/p&gt;
&lt;h1 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;原因分析&quot;&gt;&lt;/a&gt;原因分析&lt;/h1&gt;&lt;p&gt;经过提醒，将上述代码用32位的方式编译，即&lt;code&gt;gcc test_asm_A.cpp -m32&lt;/code&gt;和&lt;code&gt;gcc test_asm_B.cpp -m32&lt;/code&gt;，可以发现两段代码都能正确输出。这说明，上述代码按32位编译，可以得到正确的结果。&lt;br&gt;如果没有&lt;code&gt;-m32&lt;/code&gt;标志，则gcc默认按照64位方式编译。32位和64位程序在编译时有如下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32位和64位程序的地址空间范围不同。&lt;/li&gt;
&lt;li&gt;32位和64位程序的系统调用号不同，如本例中的write，在32位系统中调用号为4，在64位系统中则为1。&lt;/li&gt;
&lt;li&gt;对于32位程序，应调用&lt;code&gt;int $0x80&lt;/code&gt;进入系统调用，将系统调用号传入&lt;code&gt;eax&lt;/code&gt;，各个参数按照&lt;code&gt;ebx&lt;/code&gt;、&lt;code&gt;ecx&lt;/code&gt;、&lt;code&gt;edx&lt;/code&gt;的顺序传递到寄存器中，系统调用返回值储存到&lt;code&gt;eax&lt;/code&gt;寄存器。&lt;/li&gt;
&lt;li&gt;对于64位程序，应调用&lt;code&gt;syscall&lt;/code&gt;进入系统调用，将系统调用号传入&lt;code&gt;rax&lt;/code&gt;，各个参数按照&lt;code&gt;rdi&lt;/code&gt;、&lt;code&gt;rsi&lt;/code&gt;、&lt;code&gt;rdx&lt;/code&gt;的顺序传递到寄存器中，系统调用返回值储存到&lt;code&gt;rax&lt;/code&gt;寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看上面两段代码，它们都是调用&lt;code&gt;int $0x80&lt;/code&gt;进入系统调用，却按照64位方式编译，则会出现如下不正常情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序的地址空间是64位地址空间。&lt;/li&gt;
&lt;li&gt;0x80号中断进入的是32位系统调用函数，因此仍按照32位的方式来解释系统调用，即所有寄存器只考虑低32位的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看程序中传入的各个参数，系统调用号（4），第1个和第3个参数（0和6）都是32位以内的，但是&lt;strong&gt;str的地址是64位地址，在0x80系统调用中只有低32位会被考虑。&lt;/strong&gt;&lt;br&gt;这样，&lt;code&gt;test_asm_A.cpp&lt;/code&gt;不能正确执行，而&lt;code&gt;test_asm_B.cpp&lt;/code&gt;可以正确执行的原因就很明确了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;test_asm_A.cpp&lt;/code&gt;中，str存储在栈空间中，而&lt;strong&gt;栈空间在系统的高位，只取低32位地址，得到的是错误地址。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;test_asm_B.cpp&lt;/code&gt;中，str存储在堆空间中，而&lt;strong&gt;堆空间在系统的低位开始，在这样一个小程序中，str地址的高32位为0，只有低32位存在非零值，因此不会出现截断错误。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，&lt;code&gt;test_asm_B.cpp&lt;/code&gt;正确执行只是一个假象。由于堆空间从低位开始，如果开辟空间过多，堆空间也进入高位的时候，这段代码同样可能出错。&lt;/p&gt;
&lt;h1 id=&quot;64位系统的系统调用代码&quot;&gt;&lt;a href=&quot;#64位系统的系统调用代码&quot; class=&quot;headerlink&quot; title=&quot;64位系统的系统调用代码&quot;&gt;&lt;/a&gt;64位系统的系统调用代码&lt;/h1&gt;&lt;p&gt;最后，给出64位系统下可正确输出的asm系统调用代码：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_C.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char str[] = &quot;Hello\n&quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//注意：64位系统调用中，write函数调用号为1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&quot;mov %2, %%rsi\n\t&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&quot;syscall&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&quot;a&quot;(1), &quot;D&quot;(0), &quot;b&quot;(str), &quot;d&quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习系统调用，一段用asm内联汇编写的简单程序始终得不出正确的结果，后来了解到这是32位平台和64位平台的系统调用方法不同的原因。在此列出相关的程序和我的理解。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="内核" scheme="http://cxsmarkchan.github.com/categories/linux/%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="asm" scheme="http://cxsmarkchan.github.com/tags/asm/"/>
    
      <category term="系统调用" scheme="http://cxsmarkchan.github.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="64位" scheme="http://cxsmarkchan.github.com/tags/64%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>用asm内联汇编实现系统调用</title>
    <link href="http://cxsmarkchan.github.com/2016/04/01/asm-syscall/"/>
    <id>http://cxsmarkchan.github.com/2016/04/01/asm-syscall/</id>
    <published>2016-04-01T20:23:12.000Z</published>
    <updated>2017-09-25T22:52:56.918Z</updated>
    
    <content type="html">&lt;p&gt;CPU运行状态被分为内核态和用户态。操作系统在内核态下运行，拥有所有计算机资源的操作权限。而一般的应用程序则在用户态下运行，它们不能直接操作底层的硬件设备。应用程序在需要使用硬件资源时，可通过系统调用（system call）切换到内核态。本文通过asm内联汇编，分析系统调用的全过程。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容：cxsmarkchan&lt;br&gt;转载请注明出处&lt;br&gt;首次发表于csdn：&lt;a href=&quot;http://blog.csdn.net/cxsmarkchan/article/details/50939769&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用asm内联汇编实现系统调用&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Linux内核分析》MOOC课程&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-系统调用的概念&quot;&gt;&lt;a href=&quot;#1-系统调用的概念&quot; class=&quot;headerlink&quot; title=&quot;1 系统调用的概念&quot;&gt;&lt;/a&gt;1 系统调用的概念&lt;/h1&gt;&lt;p&gt;下图是一个典型的系统调用图示：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160320231125982&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;从该函数可以看到，系统调用分成如下过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户态程序调用API函数&lt;code&gt;xyz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;xyz&lt;/code&gt;接口函数内部，通过中断号&lt;code&gt;0x80&lt;/code&gt;进入系统调用，此时CPU进入内核态。&lt;/li&gt;
&lt;li&gt;CPU开始执行中断处理程序，根据用户传入的信息（系统调用号和相关参数），执行相应的内核态函数，并返回结果。&lt;br&gt;这里有两个问题：&lt;/li&gt;
&lt;li&gt;内核态的切换是通过中断方式进入的，而产生中断时只能传入一个中断向量（即&lt;code&gt;0x80&lt;/code&gt;），而系统调用有大量的API函数，系统如何知道调用哪一个函数呢？&lt;/li&gt;
&lt;li&gt;有一些API函数带有参数，而系统调用并没有才有函数调用（&lt;code&gt;call&lt;/code&gt;）方式，那么参数如何传递到被调用函数？&lt;br&gt;答案是：在调用&lt;code&gt;int 0x80&lt;/code&gt;进入系统调用前，预先把系统调用号和相关参数存入指定的寄存器中。这样，系统调用函数只需要访问相应的寄存器，就可以获得所有的信息。&lt;br&gt;事实上，在进入系统调用前，首先需要将系统调用号传入&lt;code&gt;eax&lt;/code&gt;寄存器中，并将参数依次传入&lt;code&gt;ebx&lt;/code&gt;、&lt;code&gt;ecx&lt;/code&gt;、&lt;code&gt;edx&lt;/code&gt;、&lt;code&gt;esi&lt;/code&gt;、&lt;code&gt;edi&lt;/code&gt;、&lt;code&gt;ebp&lt;/code&gt;寄存器中。系统调用最多只能传入6个参数，如果参数多于6个，则需要将参数预存在内存中，然后将参数指针传入寄存器。系统调用结束后，&lt;code&gt;eax&lt;/code&gt;会被替换为系统调用返回值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-用asm实现系统调用的实例&quot;&gt;&lt;a href=&quot;#2-用asm实现系统调用的实例&quot; class=&quot;headerlink&quot; title=&quot;2 用asm实现系统调用的实例&quot;&gt;&lt;/a&gt;2 用asm实现系统调用的实例&lt;/h1&gt;&lt;p&gt;本文运行平台为&lt;a href=&quot;https://www.shiyanlou.com/courses/195&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验楼Linux内核分析&lt;/a&gt;的第4个实验，运行环境为linux系统。&lt;br&gt;为了验证系统调用的全过程，我们以exit函数为例，给出代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    switch(id)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case 0:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //用C语言的方式调用exit函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;C exit\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            exit(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //用内联汇编的方式调用exit函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;asm exit\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;mov $0, %%ebx\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;mov $0x1, %%eax\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;others\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;before return\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该函数中，首先输入参数id。如果id为0，则调用C代码的exit函数。如果id为1，则调用汇编代码的exit函数。如果id为其他值，则顺序执行至main函数结尾。&lt;br&gt;事实上，上文的代码采用C代码和内联汇编实现了等价的功能，即&lt;code&gt;exit(0)&lt;/code&gt;功能。可以分析一下内联汇编的工作方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mov $0, %ebx&lt;/code&gt;：exit函数的第1个参数（也是唯一一个参数）为0，按照寄存器顺序，应该放在&lt;code&gt;ebx&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov $0x1, %eax&lt;/code&gt;：exit函数的系统调用号为&lt;code&gt;0x1&lt;/code&gt;，因此把系统调用号放入&lt;code&gt;eax&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int 0x80&lt;/code&gt;：产生中断，中断号&lt;code&gt;0x80&lt;/code&gt;表示系统调用。&lt;br&gt;执行了以上3步，即为执行了exit(0)函数。程序的运行结果如下：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160320233359080&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;可见，输入0或1时，都没有输出&lt;code&gt;&amp;quot;before return&amp;quot;&lt;/code&gt;，说明exit被成功调用，程序提前退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;3-小结&quot;&gt;&lt;a href=&quot;#3-小结&quot; class=&quot;headerlink&quot; title=&quot;3 小结&quot;&gt;&lt;/a&gt;3 小结&lt;/h1&gt;&lt;p&gt;系统调用既保证了操作系统的安全运行，也方便了用户态程序使用系统资源。用内联汇编的方式处理系统调用，可以很清晰地看出系统调用的过程，以及系统调用的参数传递方式。系统调用通过寄存器传递参数，因此在进行系统调用前，通常还需要备份相关寄存器中的信息。不过，在内联汇编中，这个工作会被编译器代劳。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CPU运行状态被分为内核态和用户态。操作系统在内核态下运行，拥有所有计算机资源的操作权限。而一般的应用程序则在用户态下运行，它们不能直接操作底层的硬件设备。应用程序在需要使用硬件资源时，可通过系统调用（system call）切换到内核态。本文通过asm内联汇编，分析系统调用的全过程。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="内核" scheme="http://cxsmarkchan.github.com/categories/linux/%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://cxsmarkchan.github.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编" scheme="http://cxsmarkchan.github.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="asm" scheme="http://cxsmarkchan.github.com/tags/asm/"/>
    
      <category term="系统调用" scheme="http://cxsmarkchan.github.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://cxsmarkchan.github.com/2016/03/30/firstblog/"/>
    <id>http://cxsmarkchan.github.com/2016/03/30/firstblog/</id>
    <published>2016-03-30T04:27:55.000Z</published>
    <updated>2017-09-25T22:52:56.986Z</updated>
    
    <content type="html">&lt;p&gt;&amp;emsp;&amp;emsp;博士入学已经一年半了，走过不少弯路，也算有一些成长。一直想抽时间做个博客，记录自己的学习和科研生活，最近终于付诸行动。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;电气工程是一个和计算机结合紧密的专业，我在做电力系统方向的科研时，也常常需要设计算法、编写程序。不过，直到去年，在董老师和浩哥的带领下，我才对码农的世界有了更多的了解，也越来越觉得自己如井底之蛙一般。因此，也希望更系统、更深入地学习计算机科学的知识，并将其融入到自己的科研中。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我会在这里记录自己的学习和思考，努力进步。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最后，希望自己能坚持下去^_^&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PS: 该博客用&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;搭建。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PPS: 之前在csdn上写过几篇博客，如果有空的话也会迁移过来。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;博士入学已经一年半了，走过不少弯路，也算有一些成长。一直想抽时间做个博客，记录自己的学习和科研生活，最近终于付诸行动。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://cxsmarkchan.github.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="博客" scheme="http://cxsmarkchan.github.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://cxsmarkchan.github.com/tags/hexo/"/>
    
  </entry>
  
</feed>
