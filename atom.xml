<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cxsmarkchan的博客</title>
  <subtitle>cxsmarkchan的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cxsmarkchan.github.com/"/>
  <updated>2016-04-02T02:45:20.436Z</updated>
  <id>http://cxsmarkchan.github.com/</id>
  
  <author>
    <name>cxsmarkchan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统调用：32位和64位的区别</title>
    <link href="http://cxsmarkchan.github.com/2016/04/02/asm-syscall-64/"/>
    <id>http://cxsmarkchan.github.com/2016/04/02/asm-syscall-64/</id>
    <published>2016-04-02T02:45:20.000Z</published>
    <updated>2016-04-02T02:45:20.436Z</updated>
    
    <content type="html">&lt;p&gt;最近在学习系统调用，一段用asm内联汇编写的简单程序始终得不出正确的结果，后来了解到这是32位平台和64位平台的系统调用方法不同的原因。在此列出相关的程序和我的理解。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;原创内容：cxsmarkchan&lt;br&gt;转载请注明出处&lt;br&gt;首次发表于csdn：&lt;a href=&quot;http://blog.csdn.net/cxsmarkchan/article/details/50987222&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux asm系统调用：32位和64位的区别&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;程序代码和问题&quot;&gt;&lt;a href=&quot;#程序代码和问题&quot; class=&quot;headerlink&quot; title=&quot;程序代码和问题&quot;&gt;&lt;/a&gt;程序代码和问题&lt;/h1&gt;&lt;p&gt;首先看如下一段简单的C程序（&lt;code&gt;test.cpp&lt;/code&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[] = &lt;span class=&quot;string&quot;&gt;&quot;Hello\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	write(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, str, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段程序调用了write函数，其接口为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int write(int fd /*输出位置句柄*/, const char* src /*输出首地址*/， int len /*长度*/)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;fd为0则表示输出到控制台。因此上述程序的执行结果为：向控制台输出一个长度为6的字符串&lt;code&gt;&amp;quot;Hello\n&amp;quot;&lt;/code&gt;。&lt;br&gt;在控制台调用&lt;code&gt;gcc test.cpp&lt;/code&gt;，可以正确输出。&lt;br&gt;为了更好地理解在汇编代码下的系统调用过程，可把上述代码改写成内联汇编的格式（具体语法可参考上一篇博客：&lt;a href=&quot;http://cxsmarkchan.github.io/2016/04/01/asm-syscall&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用asm内联汇编实现系统调用&lt;/a&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_A.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char str[] = &amp;quot;Hello\n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&amp;quot;a&amp;quot;(4), &amp;quot;b&amp;quot;(0), &amp;quot;c&amp;quot;(str), &amp;quot;d&amp;quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，4是write函数的系统调用号，ebx/ecx/edx是系统调用的前三个参数。&lt;br&gt;&lt;strong&gt;然而，执行&lt;code&gt;gcc test_asm_A.cpp&lt;/code&gt;编译后，再运行程序，发现程序没有任何输出&lt;/strong&gt;。一个很奇怪的问题是，如果采用如下&lt;code&gt;test_asm_B.cpp&lt;/code&gt;的写法，则程序可以正常地输出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_B.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char *str = (char*)malloc(7 * sizeof(char));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	strcpy(str, &amp;quot;Hello\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&amp;quot;a&amp;quot;(4), &amp;quot;b&amp;quot;(0), &amp;quot;c&amp;quot;(str), &amp;quot;d&amp;quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两段代码唯一的区别，是&lt;code&gt;test_asm_A.cpp&lt;/code&gt;中的&lt;code&gt;str&lt;/code&gt;存储在栈空间，而&lt;code&gt;test_asm_B.cpp&lt;/code&gt;中的&lt;code&gt;str&lt;/code&gt;存储在堆空间。&lt;/strong&gt;&lt;br&gt;那么，为什么存储位置的不同会造成完全不同的结果呢？&lt;/p&gt;
&lt;h1 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;原因分析&quot;&gt;&lt;/a&gt;原因分析&lt;/h1&gt;&lt;p&gt;经过提醒，将上述代码用32位的方式编译，即&lt;code&gt;gcc test_asm_A.cpp -m32&lt;/code&gt;和&lt;code&gt;gcc test_asm_B.cpp -m32&lt;/code&gt;，可以发现两段代码都能正确输出。这说明，上述代码按32位编译，可以得到正确的结果。&lt;br&gt;如果没有&lt;code&gt;-m32&lt;/code&gt;标志，则gcc默认按照64位方式编译。32位和64位程序在编译时有如下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32位和64位程序的地址空间范围不同。&lt;/li&gt;
&lt;li&gt;32位和64位程序的系统调用号不同，如本例中的write，在32位系统中调用号为4，在64位系统中则为1。&lt;/li&gt;
&lt;li&gt;对于32位程序，应调用&lt;code&gt;int $0x80&lt;/code&gt;进入系统调用，将系统调用号传入&lt;code&gt;eax&lt;/code&gt;，各个参数按照&lt;code&gt;ebx&lt;/code&gt;、&lt;code&gt;ecx&lt;/code&gt;、&lt;code&gt;edx&lt;/code&gt;的顺序传递到寄存器中，系统调用返回值储存到&lt;code&gt;eax&lt;/code&gt;寄存器。&lt;/li&gt;
&lt;li&gt;对于64位程序，应调用&lt;code&gt;syscall&lt;/code&gt;进入系统调用，将系统调用号传入&lt;code&gt;rax&lt;/code&gt;，各个参数按照&lt;code&gt;rdi&lt;/code&gt;、&lt;code&gt;rsi&lt;/code&gt;、&lt;code&gt;rdx&lt;/code&gt;的顺序传递到寄存器中，系统调用返回值储存到&lt;code&gt;rax&lt;/code&gt;寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看上面两段代码，它们都是调用&lt;code&gt;int $0x80&lt;/code&gt;进入系统调用，却按照64位方式编译，则会出现如下不正常情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序的地址空间是64位地址空间。&lt;/li&gt;
&lt;li&gt;0x80号中断进入的是32位系统调用函数，因此仍按照32位的方式来解释系统调用，即所有寄存器只考虑低32位的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看程序中传入的各个参数，系统调用号（4），第1个和第3个参数（0和6）都是32位以内的，但是&lt;strong&gt;str的地址是64位地址，在0x80系统调用中只有低32位会被考虑。&lt;/strong&gt;&lt;br&gt;这样，&lt;code&gt;test_asm_A.cpp&lt;/code&gt;不能正确执行，而&lt;code&gt;test_asm_B.cpp&lt;/code&gt;可以正确执行的原因就很明确了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;test_asm_A.cpp&lt;/code&gt;中，str存储在栈空间中，而&lt;strong&gt;栈空间在系统的高位，只取低32位地址，得到的是错误地址。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;test_asm_B.cpp&lt;/code&gt;中，str存储在堆空间中，而&lt;strong&gt;堆空间在系统的低位开始，在这样一个小程序中，str地址的高32位为0，只有低32位存在非零值，因此不会出现截断错误。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，&lt;code&gt;test_asm_B.cpp&lt;/code&gt;正确执行只是一个假象。由于堆空间从低位开始，如果开辟空间过多，堆空间也进入高位的时候，这段代码同样可能出错。&lt;/p&gt;
&lt;h1 id=&quot;64位系统的系统调用代码&quot;&gt;&lt;a href=&quot;#64位系统的系统调用代码&quot; class=&quot;headerlink&quot; title=&quot;64位系统的系统调用代码&quot;&gt;&lt;/a&gt;64位系统的系统调用代码&lt;/h1&gt;&lt;p&gt;最后，给出64位系统下可正确输出的asm系统调用代码：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_C.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char str[] = &quot;Hello\n&quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//注意：64位系统调用中，write函数调用号为1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&quot;mov %2, %%rsi\n\t&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&quot;syscall&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&quot;a&quot;(1), &quot;D&quot;(0), &quot;b&quot;(str), &quot;d&quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习系统调用，一段用asm内联汇编写的简单程序始终得不出正确的结果，后来了解到这是32位平台和64位平台的系统调用方法不同的原因。在此列出相关的程序和我的理解。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="内核" scheme="http://cxsmarkchan.github.com/categories/linux/%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="系统调用" scheme="http://cxsmarkchan.github.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="64位" scheme="http://cxsmarkchan.github.com/tags/64%E4%BD%8D/"/>
    
      <category term="asm" scheme="http://cxsmarkchan.github.com/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>用asm内联汇编实现系统调用</title>
    <link href="http://cxsmarkchan.github.com/2016/04/01/asm-syscall/"/>
    <id>http://cxsmarkchan.github.com/2016/04/01/asm-syscall/</id>
    <published>2016-04-01T08:23:12.000Z</published>
    <updated>2016-04-01T08:23:12.458Z</updated>
    
    <content type="html">&lt;p&gt;CPU运行状态被分为内核态和用户态。操作系统在内核态下运行，拥有所有计算机资源的操作权限。而一般的应用程序则在用户态下运行，它们不能直接操作底层的硬件设备。应用程序在需要使用硬件资源时，可通过系统调用（system call）切换到内核态。本文通过asm内联汇编，分析系统调用的全过程。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容：cxsmarkchan&lt;br&gt;转载请注明出处&lt;br&gt;首次发表于csdn：&lt;a href=&quot;http://blog.csdn.net/cxsmarkchan/article/details/50939769&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用asm内联汇编实现系统调用&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Linux内核分析》MOOC课程&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-系统调用的概念&quot;&gt;&lt;a href=&quot;#1-系统调用的概念&quot; class=&quot;headerlink&quot; title=&quot;1 系统调用的概念&quot;&gt;&lt;/a&gt;1 系统调用的概念&lt;/h1&gt;&lt;p&gt;下图是一个典型的系统调用图示：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160320231125982&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;从该函数可以看到，系统调用分成如下过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户态程序调用API函数&lt;code&gt;xyz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;xyz&lt;/code&gt;接口函数内部，通过中断号&lt;code&gt;0x80&lt;/code&gt;进入系统调用，此时CPU进入内核态。&lt;/li&gt;
&lt;li&gt;CPU开始执行中断处理程序，根据用户传入的信息（系统调用号和相关参数），执行相应的内核态函数，并返回结果。&lt;br&gt;这里有两个问题：&lt;/li&gt;
&lt;li&gt;内核态的切换是通过中断方式进入的，而产生中断时只能传入一个中断向量（即&lt;code&gt;0x80&lt;/code&gt;），而系统调用有大量的API函数，系统如何知道调用哪一个函数呢？&lt;/li&gt;
&lt;li&gt;有一些API函数带有参数，而系统调用并没有才有函数调用（&lt;code&gt;call&lt;/code&gt;）方式，那么参数如何传递到被调用函数？&lt;br&gt;答案是：在调用&lt;code&gt;int 0x80&lt;/code&gt;进入系统调用前，预先把系统调用号和相关参数存入指定的寄存器中。这样，系统调用函数只需要访问相应的寄存器，就可以获得所有的信息。&lt;br&gt;事实上，在进入系统调用前，首先需要将系统调用号传入&lt;code&gt;eax&lt;/code&gt;寄存器中，并将参数依次传入&lt;code&gt;ebx&lt;/code&gt;、&lt;code&gt;ecx&lt;/code&gt;、&lt;code&gt;edx&lt;/code&gt;、&lt;code&gt;esi&lt;/code&gt;、&lt;code&gt;edi&lt;/code&gt;、&lt;code&gt;ebp&lt;/code&gt;寄存器中。系统调用最多只能传入6个参数，如果参数多于6个，则需要将参数预存在内存中，然后将参数指针传入寄存器。系统调用结束后，&lt;code&gt;eax&lt;/code&gt;会被替换为系统调用返回值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-用asm实现系统调用的实例&quot;&gt;&lt;a href=&quot;#2-用asm实现系统调用的实例&quot; class=&quot;headerlink&quot; title=&quot;2 用asm实现系统调用的实例&quot;&gt;&lt;/a&gt;2 用asm实现系统调用的实例&lt;/h1&gt;&lt;p&gt;本文运行平台为&lt;a href=&quot;https://www.shiyanlou.com/courses/195&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验楼Linux内核分析&lt;/a&gt;的第4个实验，运行环境为linux系统。&lt;br&gt;为了验证系统调用的全过程，我们以exit函数为例，给出代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    switch(id)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case 0:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //用C语言的方式调用exit函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;C exit\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            exit(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //用内联汇编的方式调用exit函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;asm exit\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;mov $0, %%ebx\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;mov $0x1, %%eax\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;others\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;before return\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该函数中，首先输入参数id。如果id为0，则调用C代码的exit函数。如果id为1，则调用汇编代码的exit函数。如果id为其他值，则顺序执行至main函数结尾。&lt;br&gt;事实上，上文的代码采用C代码和内联汇编实现了等价的功能，即&lt;code&gt;exit(0)&lt;/code&gt;功能。可以分析一下内联汇编的工作方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mov $0, %ebx&lt;/code&gt;：exit函数的第1个参数（也是唯一一个参数）为0，按照寄存器顺序，应该放在&lt;code&gt;ebx&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov $0x1, %eax&lt;/code&gt;：exit函数的系统调用号为&lt;code&gt;0x1&lt;/code&gt;，因此把系统调用号放入&lt;code&gt;eax&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int 0x80&lt;/code&gt;：产生中断，中断号&lt;code&gt;0x80&lt;/code&gt;表示系统调用。&lt;br&gt;执行了以上3步，即为执行了exit(0)函数。程序的运行结果如下：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160320233359080&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;可见，输入0或1时，都没有输出&lt;code&gt;&amp;quot;before return&amp;quot;&lt;/code&gt;，说明exit被成功调用，程序提前退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;3-小结&quot;&gt;&lt;a href=&quot;#3-小结&quot; class=&quot;headerlink&quot; title=&quot;3 小结&quot;&gt;&lt;/a&gt;3 小结&lt;/h1&gt;&lt;p&gt;系统调用既保证了操作系统的安全运行，也方便了用户态程序使用系统资源。用内联汇编的方式处理系统调用，可以很清晰地看出系统调用的过程，以及系统调用的参数传递方式。系统调用通过寄存器传递参数，因此在进行系统调用前，通常还需要备份相关寄存器中的信息。不过，在内联汇编中，这个工作会被编译器代劳。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CPU运行状态被分为内核态和用户态。操作系统在内核态下运行，拥有所有计算机资源的操作权限。而一般的应用程序则在用户态下运行，它们不能直接操作底层的硬件设备。应用程序在需要使用硬件资源时，可通过系统调用（system call）切换到内核态。本文通过asm内联汇编，分析系统调用的全过程。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="内核" scheme="http://cxsmarkchan.github.com/categories/linux/%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="系统调用" scheme="http://cxsmarkchan.github.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="asm" scheme="http://cxsmarkchan.github.com/tags/asm/"/>
    
      <category term="操作系统" scheme="http://cxsmarkchan.github.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编" scheme="http://cxsmarkchan.github.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://cxsmarkchan.github.com/2016/03/30/firstblog/"/>
    <id>http://cxsmarkchan.github.com/2016/03/30/firstblog/</id>
    <published>2016-03-29T16:27:55.000Z</published>
    <updated>2016-03-30T15:14:05.555Z</updated>
    
    <content type="html">&lt;p&gt;&amp;emsp;&amp;emsp;博士入学已经一年半了，走过不少弯路，也算有一些成长。一直想抽时间做个博客，记录自己的学习和科研生活，最近终于付诸行动。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;电气工程是一个和计算机结合紧密的专业，我在做电力系统方向的科研时，也常常需要设计算法、编写程序。不过，直到去年，在董老师和浩哥的带领下，我才对码农的世界有了更多的了解，也越来越觉得自己如井底之蛙一般。因此，也希望更系统、更深入地学习计算机科学的知识，并将其融入到自己的科研中。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我会在这里记录自己的学习和思考，努力进步。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最后，希望自己能坚持下去^_^&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PS: 该博客用&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;搭建。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PPS: 之前在csdn上写过几篇博客，如果有空的话也会迁移过来。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;博士入学已经一年半了，走过不少弯路，也算有一些成长。一直想抽时间做个博客，记录自己的学习和科研生活，最近终于付诸行动。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://cxsmarkchan.github.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="博客" scheme="http://cxsmarkchan.github.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://cxsmarkchan.github.com/tags/hexo/"/>
    
  </entry>
  
</feed>
