<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cxsmarkchan的博客</title>
  <subtitle>cxsmarkchan的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cxsmarkchan.github.com/"/>
  <updated>2016-04-04T04:12:41.642Z</updated>
  <id>http://cxsmarkchan.github.com/</id>
  
  <author>
    <name>cxsmarkchan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux源码分析：fork复制进程</title>
    <link href="http://cxsmarkchan.github.com/2016/04/03/linux-fork/"/>
    <id>http://cxsmarkchan.github.com/2016/04/03/linux-fork/</id>
    <published>2016-04-03T13:04:54.000Z</published>
    <updated>2016-04-04T04:12:41.642Z</updated>
    
    <content type="html">&lt;p&gt;fork函数是linux系统的一个API，用于将当前进程复制，并创建一个新的进程。本文从linux源码的角度分析fork的实现过程，并学习linux创建新进程的过程。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容：cxsmarkchan 陈晓爽&lt;br&gt;转载请注明出处&lt;br&gt;&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Linux内核分析》MOOC课程&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-fork函数&quot;&gt;&lt;a href=&quot;#1-fork函数&quot; class=&quot;headerlink&quot; title=&quot;1 fork函数&quot;&gt;&lt;/a&gt;1 fork函数&lt;/h1&gt;&lt;p&gt;在Linux系统下书写如下C语言代码：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid = fork();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Failed!&quot;&lt;/span&gt;\n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pid == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This is Child Process!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This is Parent Process!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样一段程序的执行结果如下（注意两条语句的执行顺序并不完全确定）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;This is Parent Process!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This is Child Process!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有意思的事情是：两条输出语句被写在if-elseif-else语句的不同分支中，但输出时竟然两条语句均输出了！&lt;br&gt;这正是fork函数的作用：它把当前进程状态和相关数据都复制了一份，系统中有两个进程在运行。新生成的进程与原进程的状态完全相同，因此它也会“认为”自己调用了fork函数，并从fork()函数中返回。但是，两个进程的fork函数返回值并不相等。对于父进程，返回的pid是其子进程的pid。对于子进程，返回的pid则是0。因此，会出现两条输出语句。&lt;br&gt;接下来，我们会分析fork语句在linux源码中的实现。我们关心的重点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新进程的堆栈空间是如何分配的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新进程如何保证与原进程有相同的堆栈状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新进程的起始执行点如何确定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何使新进程的返回值和原进程不同**&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-fork的源码分析&quot;&gt;&lt;a href=&quot;#2-fork的源码分析&quot; class=&quot;headerlink&quot; title=&quot;2 fork的源码分析&quot;&gt;&lt;/a&gt;2 fork的源码分析&lt;/h1&gt;&lt;h2 id=&quot;2-1-linux的进程信息管理&quot;&gt;&lt;a href=&quot;#2-1-linux的进程信息管理&quot; class=&quot;headerlink&quot; title=&quot;2.1 linux的进程信息管理&quot;&gt;&lt;/a&gt;2.1 linux的进程信息管理&lt;/h2&gt;&lt;p&gt;linux系统为每个进程维护了一个task_struct类型的结构体变量，用于存储进程相关信息。task_struct结构定义于&lt;code&gt;include/linux/sched.h&lt;/code&gt;，其代码约400行，包含进程的id、当前状态、内存信息、文件系统信息等。这里我们仅关系以下内容：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid; &lt;span class=&quot;comment&quot;&gt;//进程id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_struct thread; &lt;span class=&quot;comment&quot;&gt;//进程当前状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，进程的id用于对进程进行唯一标识，进程的内核堆栈是操作系统为每个进程维护的一段空间（其内部包含用户堆栈和寄存器信息等），进程的当前状态则也是一个结构体，包含了进程的堆栈信息、当前运行位置、锁信息等。thread_struct在各种硬件环境中实现也不相同，在x86系统中，thread_struct定义于&lt;code&gt;arch/x86/include/asm/processor.h&lt;/code&gt;。下面列出我们关心的内容：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_struct&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sp; &lt;span class=&quot;comment&quot;&gt;//堆栈顶端&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ip; &lt;span class=&quot;comment&quot;&gt;//当前运行位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因此，在创建新进程的时候，也需要给新进程分配id，分配内核堆栈stack，并初始化进程状态thread（在fork函数中，初始化的新进程状态应该与原进程完全相同，除了fork函数的返回值）。&lt;/p&gt;
&lt;h2 id=&quot;2-2-fork调用的全过程&quot;&gt;&lt;a href=&quot;#2-2-fork调用的全过程&quot; class=&quot;headerlink&quot; title=&quot;2.2 fork调用的全过程&quot;&gt;&lt;/a&gt;2.2 fork调用的全过程&lt;/h2&gt;&lt;p&gt;fork函数并不是一个普通的函数，而是一个系统调用，而系统调用是一个软件中断，在fork函数的调用过程中（中断返回前），会生成两个进程，因此生成的两个进程都仍处在中断状态，需要从中断状态返回。调用fork函数的父进程从中断过程返回是可以理解的，只需经过恢复现场的工作就可以了。但新生成的子进程，如何保证其初始化在中断状态，并从中断状态中返回呢？进一步地，如何让两个进程的返回值不相等呢？&lt;br&gt;下面的图可以简要地说明这种情况：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-flowchart.jpg&quot; alt=&quot;fork调用示意图&quot;&gt;&lt;br&gt;在该图中可以看出，父进程仍然是正常的系统调用处理过程，但新建的新进程，则是复制了父进程的状态，并把当前语句设置在&lt;code&gt;ret_from_fork&lt;/code&gt;标签处，该标签处执行一些初始化语句后，就跳转到&lt;code&gt;syscall_exit_work&lt;/code&gt;处，退出中断状态。由于子进程和父进程的堆栈完全相同，因此返回的位置也完全相同。&lt;br&gt;而唯一不同的是两个进程的返回值，这一点的实现则是靠&lt;code&gt;ax&lt;/code&gt;寄存器。&lt;code&gt;ax&lt;/code&gt;寄存器中存储了系统调用的返回值，对于新进程来说，在&lt;code&gt;copy_thread&lt;/code&gt;函数中将新进程的&lt;code&gt;ax&lt;/code&gt;寄存器值设置为0，因此新进程的返回为0。&lt;br&gt;各个函数的位置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system_call: &lt;code&gt;arch/x86/kernel/entry_32.S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;sys_fork: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;do_fork: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy_process: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;dup_task_struct: &lt;code&gt;kernel/fork.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy_thread: &lt;code&gt;arch/x86/kernel/process_32.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ret_from_kernel: &lt;code&gt;arch/x86/kernel/entry_32.S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下会重点分析dup_task_struct和copy_thread函数，以及ret_from_kernel过程&lt;/p&gt;
&lt;h2 id=&quot;2-3-相关的函数分析&quot;&gt;&lt;a href=&quot;#2-3-相关的函数分析&quot; class=&quot;headerlink&quot; title=&quot;2.3 相关的函数分析&quot;&gt;&lt;/a&gt;2.3 相关的函数分析&lt;/h2&gt;&lt;h3 id=&quot;2-3-1-dup-task-struct：创建进程&quot;&gt;&lt;a href=&quot;#2-3-1-dup-task-struct：创建进程&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 dup_task_struct：创建进程&quot;&gt;&lt;/a&gt;2.3.1 dup_task_struct：创建进程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;dup_task_struct用于创建一个新的进程，并把当前进程的信息复制到新进程（注意当前进程的运行状态不是在这里复制）。&lt;/strong&gt;部分重要的源码和我的注释如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *&lt;span class=&quot;title&quot;&gt;dup_task_struct&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *orig)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *tsk; &lt;span class=&quot;comment&quot;&gt;//新进程的进程管理结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; thread_info *ti; &lt;span class=&quot;comment&quot;&gt;//新进程的内核堆栈结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; node = tsk_fork_get_node(orig); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; err;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tsk = alloc_task_struct_node(node); &lt;span class=&quot;comment&quot;&gt;//分配进程管理结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!tsk)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ti = alloc_thread_info_node(tsk, node); &lt;span class=&quot;comment&quot;&gt;//开辟内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!ti)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; free_tsk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	err = arch_dup_task_struct(tsk, orig); &lt;span class=&quot;comment&quot;&gt;//把orig的内容拷贝给tsk&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; free_ti;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tsk-&amp;gt;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt; = ti; &lt;span class=&quot;comment&quot;&gt;//把内核堆栈赋给tsk&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	setup_thread_stack(tsk, orig); &lt;span class=&quot;comment&quot;&gt;//初始化内核堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tsk;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;free_ti:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free_thread_info(ti);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;free_tsk:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free_task_struct(tsk);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-copy-thread：复制进程状态&quot;&gt;&lt;a href=&quot;#2-3-2-copy-thread：复制进程状态&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 copy_thread：复制进程状态&quot;&gt;&lt;/a&gt;2.3.2 copy_thread：复制进程状态&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;copy_thread用于把原进程的状态和堆栈拷贝到新进程，并设置返回值为0。&lt;/strong&gt;部分重要的源码和我的注释如下：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copy_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; clone_flags, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; sp,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; arg, &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; task_struct *p)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pt_regs *childregs = task_pt_regs(p); &lt;span class=&quot;comment&quot;&gt;// 获取新进程的内核堆栈指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;thread.sp = (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;) childregs; &lt;span class=&quot;comment&quot;&gt;// 将新进程的堆栈设置为新分配的堆栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *childregs = *current_pt_regs(); &lt;span class=&quot;comment&quot;&gt;// 复制所有的内核堆栈信息，包括寄存器信息和堆栈信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    childregs-&amp;gt;ax = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 这句话把ax设置为0，因此新进程的系统调用返回值为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    childregs-&amp;gt;sp = sp; &lt;span class=&quot;comment&quot;&gt;//复制当前堆栈信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;thread.ip = (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;) ret_from_fork; &lt;span class=&quot;comment&quot;&gt;// 设置新进程的入口位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见，该函数执行完毕后，新进程的堆栈和入口都已经确定，新进程启动时将处在中断状态，而中断返回值为0.&lt;/p&gt;
&lt;h3 id=&quot;2-3-3-ret-from-fork：退出中断&quot;&gt;&lt;a href=&quot;#2-3-3-ret-from-fork：退出中断&quot; class=&quot;headerlink&quot; title=&quot;2.3.3 ret_from_fork：退出中断&quot;&gt;&lt;/a&gt;2.3.3 ret_from_fork：退出中断&lt;/h3&gt;&lt;p&gt;这是新进程的第一条语句，当进程调度把CPU控制权交给新进程时，就会从该处向下执行。相关内容如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ENTRY(ret_from_fork)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFI_STARTPROC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pushl_cfi %eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	call schedule_tail&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	GET_THREAD_INFO(%ebp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	popl_cfi %eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pushl_cfi $0x0202		# Reset kernel eflags&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	popfl_cfi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	jmp syscall_exit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFI_ENDPROC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;END(ret_from_fork)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中有一句&lt;code&gt;jmp syscall_exit&lt;/code&gt;，而&lt;code&gt;syscall_exit&lt;/code&gt;位于系统调用函数刚结束，正准备退出中断的位置。此时&lt;code&gt;ax&lt;/code&gt;寄存器中存储了系统调用的返回值，而新进程的堆栈已经和原进程完全相同，因此会和原进程在相同的位置返回。到这里，也就得到了我们在第1节看到的结果：子进程将进入&lt;code&gt;pid == 0&lt;/code&gt;的分支。&lt;/p&gt;
&lt;h1 id=&quot;3-用gdb跟踪fork&quot;&gt;&lt;a href=&quot;#3-用gdb跟踪fork&quot; class=&quot;headerlink&quot; title=&quot;3 用gdb跟踪fork&quot;&gt;&lt;/a&gt;3 用gdb跟踪fork&lt;/h1&gt;&lt;p&gt;本节中，我们用gdb跟踪fork函数，以验证我们前面的结论。这里的实验平台采用&lt;a href=&quot;https://shiyanlou.com/courses/195&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验楼Linux内核分析&lt;/a&gt;的第6个实验：分析linux内核创建一个新进程的过程。&lt;br&gt;进入实验平台，输入如下代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd LinuxKernel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm menu -rf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/mengning/menu.git权威指南&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd menu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv test_fork.c test.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make rootfs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;即可看到启动的实验系统，在系统中输入fork命令，则可以看到如下运行结果：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-process.jpg&quot; alt=&quot;实验系统fork&quot;&gt;&lt;br&gt;为了能够用gdb跟踪，输入如下命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd ../rootfs.img -s -S&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再重启一个窗口，输入如下命令：&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ~/LinuxKernel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;file linux-3.18.6/vmlinux&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target remote:1234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c &lt;span class=&quot;comment&quot;&gt;#让程序执行一步&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;^C &lt;span class=&quot;comment&quot;&gt;#中断程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;#设置断点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;_fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b copy_process&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b dup_task_struct&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b copy_thread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b ret_from_fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置以上断点后，在模拟系统的控制台下键入fork，就可以通过断点跟踪fork的执行过程。这里就不展示所有的截图了，大致如下图：&lt;br&gt;&lt;img src=&quot;/images/linux-fork/linux-fork-break.jpg&quot; alt=&quot;断点跟踪&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;4-小结&quot;&gt;&lt;a href=&quot;#4-小结&quot; class=&quot;headerlink&quot; title=&quot;4 小结&quot;&gt;&lt;/a&gt;4 小结&lt;/h1&gt;&lt;p&gt;Linux调用fork复制一个新进程需要经过如下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入系统中断，调用sys_fork函数&lt;/li&gt;
&lt;li&gt;sys_fork调用do_fork函数&lt;/li&gt;
&lt;li&gt;do_fork调用copy_process函数&lt;/li&gt;
&lt;li&gt;copy_process调用dup_task_struct函数，将父进程的task_struct拷贝给子进程，并为子进程创建单独的进程控制块和内核堆栈空间。新的进程就在这里诞生了。&lt;/li&gt;
&lt;li&gt;copy_process调用copy_thread函数，把父进程的堆栈信息复制给子进程，并将ax寄存器设置为0。然后，子进程的入口地点被设置为&lt;code&gt;ret_from_fork&lt;/code&gt;标签。&lt;/li&gt;
&lt;li&gt;父进程的系统调用逐层返回，返回值为子进程的pid。&lt;/li&gt;
&lt;li&gt;子进程在获得CPU控制权时，会执行&lt;code&gt;ret_from_fork&lt;/code&gt;，而&lt;code&gt;ret_from_fork&lt;/code&gt;会跳转到&lt;code&gt;syscall_exit&lt;/code&gt;标签，退出中断。由于&lt;code&gt;ax&lt;/code&gt;设置为0，所以系统调用返回0。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;fork函数是linux系统的一个API，用于将当前进程复制，并创建一个新的进程。本文从linux源码的角度分析fork的实现过程，并学习linux创建新进程的过程。本文分析的源码来自&lt;a href=&quot;http://codelab.shiyanlou.com/xref/linux-3.18.6&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/categories/linux/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="源码" scheme="http://cxsmarkchan.github.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="fork" scheme="http://cxsmarkchan.github.com/tags/fork/"/>
    
      <category term="进程创建" scheme="http://cxsmarkchan.github.com/tags/%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用：32位和64位的区别</title>
    <link href="http://cxsmarkchan.github.com/2016/04/02/asm-syscall-64/"/>
    <id>http://cxsmarkchan.github.com/2016/04/02/asm-syscall-64/</id>
    <published>2016-04-02T02:45:20.000Z</published>
    <updated>2016-04-02T02:45:20.436Z</updated>
    
    <content type="html">&lt;p&gt;最近在学习系统调用，一段用asm内联汇编写的简单程序始终得不出正确的结果，后来了解到这是32位平台和64位平台的系统调用方法不同的原因。在此列出相关的程序和我的理解。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;原创内容：cxsmarkchan&lt;br&gt;转载请注明出处&lt;br&gt;首次发表于csdn：&lt;a href=&quot;http://blog.csdn.net/cxsmarkchan/article/details/50987222&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux asm系统调用：32位和64位的区别&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;程序代码和问题&quot;&gt;&lt;a href=&quot;#程序代码和问题&quot; class=&quot;headerlink&quot; title=&quot;程序代码和问题&quot;&gt;&lt;/a&gt;程序代码和问题&lt;/h1&gt;&lt;p&gt;首先看如下一段简单的C程序（&lt;code&gt;test.cpp&lt;/code&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[] = &lt;span class=&quot;string&quot;&gt;&quot;Hello\n&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	write(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, str, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段程序调用了write函数，其接口为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int write(int fd /*输出位置句柄*/, const char* src /*输出首地址*/， int len /*长度*/)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;fd为0则表示输出到控制台。因此上述程序的执行结果为：向控制台输出一个长度为6的字符串&lt;code&gt;&amp;quot;Hello\n&amp;quot;&lt;/code&gt;。&lt;br&gt;在控制台调用&lt;code&gt;gcc test.cpp&lt;/code&gt;，可以正确输出。&lt;br&gt;为了更好地理解在汇编代码下的系统调用过程，可把上述代码改写成内联汇编的格式（具体语法可参考上一篇博客：&lt;a href=&quot;http://cxsmarkchan.github.io/2016/04/01/asm-syscall&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用asm内联汇编实现系统调用&lt;/a&gt;）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_A.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char str[] = &amp;quot;Hello\n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&amp;quot;a&amp;quot;(4), &amp;quot;b&amp;quot;(0), &amp;quot;c&amp;quot;(str), &amp;quot;d&amp;quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中，4是write函数的系统调用号，ebx/ecx/edx是系统调用的前三个参数。&lt;br&gt;&lt;strong&gt;然而，执行&lt;code&gt;gcc test_asm_A.cpp&lt;/code&gt;编译后，再运行程序，发现程序没有任何输出&lt;/strong&gt;。一个很奇怪的问题是，如果采用如下&lt;code&gt;test_asm_B.cpp&lt;/code&gt;的写法，则程序可以正常地输出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_B.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char *str = (char*)malloc(7 * sizeof(char));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	strcpy(str, &amp;quot;Hello\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&amp;quot;a&amp;quot;(4), &amp;quot;b&amp;quot;(0), &amp;quot;c&amp;quot;(str), &amp;quot;d&amp;quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	free(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两段代码唯一的区别，是&lt;code&gt;test_asm_A.cpp&lt;/code&gt;中的&lt;code&gt;str&lt;/code&gt;存储在栈空间，而&lt;code&gt;test_asm_B.cpp&lt;/code&gt;中的&lt;code&gt;str&lt;/code&gt;存储在堆空间。&lt;/strong&gt;&lt;br&gt;那么，为什么存储位置的不同会造成完全不同的结果呢？&lt;/p&gt;
&lt;h1 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;原因分析&quot;&gt;&lt;/a&gt;原因分析&lt;/h1&gt;&lt;p&gt;经过提醒，将上述代码用32位的方式编译，即&lt;code&gt;gcc test_asm_A.cpp -m32&lt;/code&gt;和&lt;code&gt;gcc test_asm_B.cpp -m32&lt;/code&gt;，可以发现两段代码都能正确输出。这说明，上述代码按32位编译，可以得到正确的结果。&lt;br&gt;如果没有&lt;code&gt;-m32&lt;/code&gt;标志，则gcc默认按照64位方式编译。32位和64位程序在编译时有如下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32位和64位程序的地址空间范围不同。&lt;/li&gt;
&lt;li&gt;32位和64位程序的系统调用号不同，如本例中的write，在32位系统中调用号为4，在64位系统中则为1。&lt;/li&gt;
&lt;li&gt;对于32位程序，应调用&lt;code&gt;int $0x80&lt;/code&gt;进入系统调用，将系统调用号传入&lt;code&gt;eax&lt;/code&gt;，各个参数按照&lt;code&gt;ebx&lt;/code&gt;、&lt;code&gt;ecx&lt;/code&gt;、&lt;code&gt;edx&lt;/code&gt;的顺序传递到寄存器中，系统调用返回值储存到&lt;code&gt;eax&lt;/code&gt;寄存器。&lt;/li&gt;
&lt;li&gt;对于64位程序，应调用&lt;code&gt;syscall&lt;/code&gt;进入系统调用，将系统调用号传入&lt;code&gt;rax&lt;/code&gt;，各个参数按照&lt;code&gt;rdi&lt;/code&gt;、&lt;code&gt;rsi&lt;/code&gt;、&lt;code&gt;rdx&lt;/code&gt;的顺序传递到寄存器中，系统调用返回值储存到&lt;code&gt;rax&lt;/code&gt;寄存器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看上面两段代码，它们都是调用&lt;code&gt;int $0x80&lt;/code&gt;进入系统调用，却按照64位方式编译，则会出现如下不正常情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序的地址空间是64位地址空间。&lt;/li&gt;
&lt;li&gt;0x80号中断进入的是32位系统调用函数，因此仍按照32位的方式来解释系统调用，即所有寄存器只考虑低32位的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再看程序中传入的各个参数，系统调用号（4），第1个和第3个参数（0和6）都是32位以内的，但是&lt;strong&gt;str的地址是64位地址，在0x80系统调用中只有低32位会被考虑。&lt;/strong&gt;&lt;br&gt;这样，&lt;code&gt;test_asm_A.cpp&lt;/code&gt;不能正确执行，而&lt;code&gt;test_asm_B.cpp&lt;/code&gt;可以正确执行的原因就很明确了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;test_asm_A.cpp&lt;/code&gt;中，str存储在栈空间中，而&lt;strong&gt;栈空间在系统的高位，只取低32位地址，得到的是错误地址。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;test_asm_B.cpp&lt;/code&gt;中，str存储在堆空间中，而&lt;strong&gt;堆空间在系统的低位开始，在这样一个小程序中，str地址的高32位为0，只有低32位存在非零值，因此不会出现截断错误。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，&lt;code&gt;test_asm_B.cpp&lt;/code&gt;正确执行只是一个假象。由于堆空间从低位开始，如果开辟空间过多，堆空间也进入高位的时候，这段代码同样可能出错。&lt;/p&gt;
&lt;h1 id=&quot;64位系统的系统调用代码&quot;&gt;&lt;a href=&quot;#64位系统的系统调用代码&quot; class=&quot;headerlink&quot; title=&quot;64位系统的系统调用代码&quot;&gt;&lt;/a&gt;64位系统的系统调用代码&lt;/h1&gt;&lt;p&gt;最后，给出64位系统下可正确输出的asm系统调用代码：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//test_asm_C.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	char str[] = &quot;Hello\n&quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//注意：64位系统调用中，write函数调用号为1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&quot;mov %2, %%rsi\n\t&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&quot;syscall&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		:&quot;a&quot;(1), &quot;D&quot;(0), &quot;b&quot;(str), &quot;d&quot;(6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习系统调用，一段用asm内联汇编写的简单程序始终得不出正确的结果，后来了解到这是32位平台和64位平台的系统调用方法不同的原因。在此列出相关的程序和我的理解。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="内核" scheme="http://cxsmarkchan.github.com/categories/linux/%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="asm" scheme="http://cxsmarkchan.github.com/tags/asm/"/>
    
      <category term="系统调用" scheme="http://cxsmarkchan.github.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/tags/linux/"/>
    
      <category term="64位" scheme="http://cxsmarkchan.github.com/tags/64%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>用asm内联汇编实现系统调用</title>
    <link href="http://cxsmarkchan.github.com/2016/04/01/asm-syscall/"/>
    <id>http://cxsmarkchan.github.com/2016/04/01/asm-syscall/</id>
    <published>2016-04-01T08:23:12.000Z</published>
    <updated>2016-04-01T08:23:12.458Z</updated>
    
    <content type="html">&lt;p&gt;CPU运行状态被分为内核态和用户态。操作系统在内核态下运行，拥有所有计算机资源的操作权限。而一般的应用程序则在用户态下运行，它们不能直接操作底层的硬件设备。应用程序在需要使用硬件资源时，可通过系统调用（system call）切换到内核态。本文通过asm内联汇编，分析系统调用的全过程。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原创内容：cxsmarkchan&lt;br&gt;转载请注明出处&lt;br&gt;首次发表于csdn：&lt;a href=&quot;http://blog.csdn.net/cxsmarkchan/article/details/50939769&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用asm内联汇编实现系统调用&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Linux内核分析》MOOC课程&lt;/a&gt;学习笔记&lt;/p&gt;
&lt;h1 id=&quot;1-系统调用的概念&quot;&gt;&lt;a href=&quot;#1-系统调用的概念&quot; class=&quot;headerlink&quot; title=&quot;1 系统调用的概念&quot;&gt;&lt;/a&gt;1 系统调用的概念&lt;/h1&gt;&lt;p&gt;下图是一个典型的系统调用图示：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160320231125982&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;从该函数可以看到，系统调用分成如下过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户态程序调用API函数&lt;code&gt;xyz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;xyz&lt;/code&gt;接口函数内部，通过中断号&lt;code&gt;0x80&lt;/code&gt;进入系统调用，此时CPU进入内核态。&lt;/li&gt;
&lt;li&gt;CPU开始执行中断处理程序，根据用户传入的信息（系统调用号和相关参数），执行相应的内核态函数，并返回结果。&lt;br&gt;这里有两个问题：&lt;/li&gt;
&lt;li&gt;内核态的切换是通过中断方式进入的，而产生中断时只能传入一个中断向量（即&lt;code&gt;0x80&lt;/code&gt;），而系统调用有大量的API函数，系统如何知道调用哪一个函数呢？&lt;/li&gt;
&lt;li&gt;有一些API函数带有参数，而系统调用并没有才有函数调用（&lt;code&gt;call&lt;/code&gt;）方式，那么参数如何传递到被调用函数？&lt;br&gt;答案是：在调用&lt;code&gt;int 0x80&lt;/code&gt;进入系统调用前，预先把系统调用号和相关参数存入指定的寄存器中。这样，系统调用函数只需要访问相应的寄存器，就可以获得所有的信息。&lt;br&gt;事实上，在进入系统调用前，首先需要将系统调用号传入&lt;code&gt;eax&lt;/code&gt;寄存器中，并将参数依次传入&lt;code&gt;ebx&lt;/code&gt;、&lt;code&gt;ecx&lt;/code&gt;、&lt;code&gt;edx&lt;/code&gt;、&lt;code&gt;esi&lt;/code&gt;、&lt;code&gt;edi&lt;/code&gt;、&lt;code&gt;ebp&lt;/code&gt;寄存器中。系统调用最多只能传入6个参数，如果参数多于6个，则需要将参数预存在内存中，然后将参数指针传入寄存器。系统调用结束后，&lt;code&gt;eax&lt;/code&gt;会被替换为系统调用返回值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-用asm实现系统调用的实例&quot;&gt;&lt;a href=&quot;#2-用asm实现系统调用的实例&quot; class=&quot;headerlink&quot; title=&quot;2 用asm实现系统调用的实例&quot;&gt;&lt;/a&gt;2 用asm实现系统调用的实例&lt;/h1&gt;&lt;p&gt;本文运行平台为&lt;a href=&quot;https://www.shiyanlou.com/courses/195&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验楼Linux内核分析&lt;/a&gt;的第4个实验，运行环境为linux系统。&lt;br&gt;为了验证系统调用的全过程，我们以exit函数为例，给出代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    switch(id)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case 0:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //用C语言的方式调用exit函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;C exit\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            exit(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //用内联汇编的方式调用exit函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;asm exit\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            asm volatile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;mov $0, %%ebx\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;mov $0x1, %%eax\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;quot;int $0x80\n\t&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;others\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;before return\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该函数中，首先输入参数id。如果id为0，则调用C代码的exit函数。如果id为1，则调用汇编代码的exit函数。如果id为其他值，则顺序执行至main函数结尾。&lt;br&gt;事实上，上文的代码采用C代码和内联汇编实现了等价的功能，即&lt;code&gt;exit(0)&lt;/code&gt;功能。可以分析一下内联汇编的工作方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mov $0, %ebx&lt;/code&gt;：exit函数的第1个参数（也是唯一一个参数）为0，按照寄存器顺序，应该放在&lt;code&gt;ebx&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov $0x1, %eax&lt;/code&gt;：exit函数的系统调用号为&lt;code&gt;0x1&lt;/code&gt;，因此把系统调用号放入&lt;code&gt;eax&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int 0x80&lt;/code&gt;：产生中断，中断号&lt;code&gt;0x80&lt;/code&gt;表示系统调用。&lt;br&gt;执行了以上3步，即为执行了exit(0)函数。程序的运行结果如下：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160320233359080&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;可见，输入0或1时，都没有输出&lt;code&gt;&amp;quot;before return&amp;quot;&lt;/code&gt;，说明exit被成功调用，程序提前退出。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;3-小结&quot;&gt;&lt;a href=&quot;#3-小结&quot; class=&quot;headerlink&quot; title=&quot;3 小结&quot;&gt;&lt;/a&gt;3 小结&lt;/h1&gt;&lt;p&gt;系统调用既保证了操作系统的安全运行，也方便了用户态程序使用系统资源。用内联汇编的方式处理系统调用，可以很清晰地看出系统调用的过程，以及系统调用的参数传递方式。系统调用通过寄存器传递参数，因此在进行系统调用前，通常还需要备份相关寄存器中的信息。不过，在内联汇编中，这个工作会被编译器代劳。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CPU运行状态被分为内核态和用户态。操作系统在内核态下运行，拥有所有计算机资源的操作权限。而一般的应用程序则在用户态下运行，它们不能直接操作底层的硬件设备。应用程序在需要使用硬件资源时，可通过系统调用（system call）切换到内核态。本文通过asm内联汇编，分析系统调用的全过程。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://cxsmarkchan.github.com/categories/linux/"/>
    
      <category term="内核" scheme="http://cxsmarkchan.github.com/categories/linux/%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://cxsmarkchan.github.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编" scheme="http://cxsmarkchan.github.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="asm" scheme="http://cxsmarkchan.github.com/tags/asm/"/>
    
      <category term="系统调用" scheme="http://cxsmarkchan.github.com/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://cxsmarkchan.github.com/2016/03/30/firstblog/"/>
    <id>http://cxsmarkchan.github.com/2016/03/30/firstblog/</id>
    <published>2016-03-29T16:27:55.000Z</published>
    <updated>2016-03-30T15:14:05.555Z</updated>
    
    <content type="html">&lt;p&gt;&amp;emsp;&amp;emsp;博士入学已经一年半了，走过不少弯路，也算有一些成长。一直想抽时间做个博客，记录自己的学习和科研生活，最近终于付诸行动。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;电气工程是一个和计算机结合紧密的专业，我在做电力系统方向的科研时，也常常需要设计算法、编写程序。不过，直到去年，在董老师和浩哥的带领下，我才对码农的世界有了更多的了解，也越来越觉得自己如井底之蛙一般。因此，也希望更系统、更深入地学习计算机科学的知识，并将其融入到自己的科研中。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我会在这里记录自己的学习和思考，努力进步。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最后，希望自己能坚持下去^_^&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PS: 该博客用&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;搭建。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;PPS: 之前在csdn上写过几篇博客，如果有空的话也会迁移过来。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;博士入学已经一年半了，走过不少弯路，也算有一些成长。一直想抽时间做个博客，记录自己的学习和科研生活，最近终于付诸行动。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://cxsmarkchan.github.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="博客" scheme="http://cxsmarkchan.github.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://cxsmarkchan.github.com/tags/hexo/"/>
    
  </entry>
  
</feed>
